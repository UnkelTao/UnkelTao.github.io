<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cpp | /UnkelTao]]></title>
  <link href="http://www.UnkelTao.com/blog/categories/cpp/atom.xml" rel="self"/>
  <link href="http://www.UnkelTao.com/"/>
  <updated>2014-11-16T13:04:24+00:00</updated>
  <id>http://www.UnkelTao.com/</id>
  <author>
    <name><![CDATA[UnkelTao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[2014年西南交通大学 新秀杯 ACM程序设计大赛 决赛解题报告]]></title>
    <link href="http://www.UnkelTao.com/blog/2014/11/16/2014-swjtu-acm-onsite-programming-contest/"/>
    <updated>2014-11-16T10:41:05+00:00</updated>
    <id>http://www.UnkelTao.com/blog/2014/11/16/2014-swjtu-acm-onsite-programming-contest</id>
    <content type="html"><![CDATA[<p><strong>比赛链接：</strong>  <a href="http://acm.swjtu.edu.cn/JudgeOnline/showcontest?contest_id=1135">新秀杯 ACM程序设计大赛决赛</a>  </p>

<p>比赛还算成功，算上友情参赛，总共有7个题目有人通过，第一名最后成绩为5题，虽然离我想的差一点。不过还是不错~~</p>

<!--more-->
<p>##A <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2173">从头再来</a>
只需要简单的统计单词A中每个字母出现的次数，与B中每个字母出现的次数做比较即可。</p>

<p><code>
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#define SQR(x) ((x)*(x))
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); --i)
#define MaxN  10010
#define ll long long
using namespace std;
void data(){
   freopen("data.in","r",stdin);
   freopen("data.out","w",stdout);
}
char a[MaxN],b[MaxN];
int s1[27],s2[27];
int gao(){
    memset(s1,0,sizeof(s1));
    memset(s2,0,sizeof(s2));
    int l1=strlen(a),l2=strlen(b);
    rep(i,l1) s1[a[i]-'a']++;
    rep(i,l2) s2[b[i]-'a']++;
    rep(i,26)if(s1[i]&lt;s2[i]) return 0;
    return 1;   
}
int main(){
   //data();
   while(cin&gt;&gt;a&gt;&gt;b){
      printf("%s\n",gao()?"Yes":"No");
   }
   return 0;
}
</code></p>

<h2 id="b-httpacmswjtueducnjudgeonlineshowproblemproblemid2175">B <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2175">挖掘机技术哪家强</a></h2>

<p><img src="http://unkeltao.qiniudn.com/wailian/10_onsite_B.jpg" alt="" />
  连接DF，那么ADF的面积为正方形的一半，也是矩形的一半，正方形的面积就等于矩形的面积。
  AE=a<em>a/b; DE=sqrt(a</em>a-AE*AE)</p>

<p><code>
int main(){
   //  data();
   int a,b;
   while(~scanf("%d%d",&amp;a,&amp;b)){
       double res=sqrt(a*a-(a*a*1.0/b)*(a*a*1.0/b))*(a*a*1.0/b)/2.0;
       printf("%.2lf\n",res);             
   }
   return 0;
}
</code></p>

<h2 id="c-yogykwaniphonehttpacmswjtueducnjudgeonlineshowproblemproblemid2175">C <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2175">YogyKwan的iPhone也弯了</a></h2>

<p>假设半径为r,t为输入的数据那么可以写出如下等式：
<code>r*sin(pi-15/r/2)=t/2</code>
我们可以知道，当r越大时候，t就会越小，于是我们可以二分判定。</p>

<p><code>
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
const double PI=acos(-1);
const double eps=1e-10;
int main(){
    //freopen("data.in","r",stdin);freopen("data2.out","w",stdout);
    double l,w,r,a,sj,xj,m,t;
    while(scanf("%lf",&amp;w)!=EOF){
        l=15;
        sj=l/PI,xj=0.5*l/PI;
        w*=0.5,l*=0.5;
        while(sj-xj&gt;eps){
            m=(sj+xj)*0.5;
            t=m*sin(l/m);
            if(t&gt;w) sj=m;
            else xj=m;
        }
        r=m;
        a=l/r*2;
        printf("%f %f\n",r,a);
    }
    return 0;
}
</code></p>

<h2 id="d-httpacmswjtueducnjudgeonlineshowproblemproblemid2776">D <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2776">强迫症改变世界</a></h2>

<p>不妨用 <code>f(k)</code> 来表示摆放 k 个座位的方案数。我们可以把这些方案分成两类：最后一个座位是坐女生，或者最后一个座位是坐男生。如果是前一种情形，则我们只需要看前 k – 1 座位有多少摆法就可以了；如果是后一种情形，那么倒数第二个座位必须是女生，因而这种情形下的方案数就取决于前 k – 2 个座位的安排方案数。因此我们得到， <code>f(k) = f(k – 1) + f(k – 2)</code> 其中<code>f[1]=2,f[2]=3;</code></p>

<p><code>
#define SQR(x) ((x)*(x))
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); --i)
int f[1002];
void gao(){
     f[0]=1;
     f[1]=2;
     repf(i,2,1001) f[i]=(f[i-1]+f[i-2])%mod;           
}
int main(){
    //data();
    int n;
    gao();
    while(~scanf("%d",&amp;n)){
        printf("%ld\n",f[n]);
    }
    return 0;
}
</code></p>

<h2 id="e-2httpacmswjtueducnjudgeonlineshowproblemproblemid2177">E <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2177">强迫症改变世界2</a></h2>

<p>此题需要先会容斥定理， n以内a,b的倍数的个数有， <code>sum=n/a+n/b+n/lcm(a,b)</code>;
然后我们枚举出所有的只含有4或者7的数字（大概1000个），然后去掉是前面出现过得数的倍数的数（如44是4的倍数） 大概还剩下不到600个，看起来很大，因为容斥定理的复杂度是2^n次方，但是，此题r的范围不是小，我们在做lcm的时候，很快就会超过范围，就不需要继续向下了，然后我们从大往小做，大概只需要递归10万次左右。</p>

<p>剩下的可以参考代码。</p>

<p><code>
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cctype&gt;
#include &lt;ctime&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#define SQR(x) ((x)*(x))
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); --i)
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define pow2(n) (1&lt;&lt;(n))
#define pi acos(-1)
#define eps 0.00000001
#define lg(n) log10((n)*1.0)
#define MaxN  1000000000
#define mod 1000000007
#define md(x) (((x)%mod+mod)%mod)
#define ll long long
using namespace std;
void data(){
   freopen("sample.in","r",stdin);
   freopen("sample.out","w",stdout);
}
ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
int t,n,m;
ll l,r,ans,a[3000],b[3000];
bool vis[3000];
void pre(int x,ll y)
{
  if(y&gt;MaxN)return;
  if(x&gt;0)a[++m]=y;
  pre(x+1,y*10+4);
  pre(x+1,y*10+7);
}
void gao(){
  sort(a+1,a+m+1);
  repd(i,m)
     if(!vis[i])
     {
         b[++n]=a[i];
         for(int j=i+1;j&lt;=m;j++)
             if(!(a[j]%a[i]))
                 vis[j]=1;
     }
  repd(i,n) a[n-i+1]=b[i];
}
void dfs(int x,int y,ll z)
{
  if(x&gt;n)
  {
    if(y&amp;1)ans+=r/z-(l-1)/z;
    else if(y)ans-=r/z-(l-1)/z;
    return;
  }
  dfs(x+1,y,z);
  ll tmp=z/gcd(a[x],z);
  if((a[x]*tmp)&lt;=r) dfs(x+1,y+1,a[x]*tmp);
}
int main()
{
    //data();
    pre(0,0);
    gao();
    while(~scanf("%lld%lld",&amp;l,&amp;r)){
      ans=0;
      dfs(1,0,1);
      printf("%lld\n",ans);
    }
    return 0;
}
</code></p>

<h2 id="f-iihttpacmswjtueducnjudgeonlineshowproblemproblemid2178">F <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2178">不幸的程序员II</a></h2>
<p>矩阵快速幂，如果你还不会这个，那么该先去学习矩阵快速幂。</p>

<p>简单公式推导如下:
<img src="http://unkeltao.qiniudn.com/wailian/10_F_1.png" alt="" />
<img src="http://unkeltao.qiniudn.com/wailian/10_F_2.png" alt="" /></p>

<p><code>
#include &lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
using namespace std;
const int MAX = 3;
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); --i)
#define mod 1000000007
#define ll long long
typedef struct
{
   ll m[MAX][MAX];
} Matrix;
Matrix P;
Matrix I ={1,0,0,0,1,0,0,0,1};
Matrix matrixmul(Matrix a,Matrix b) 
{
   int i,j,k;
   Matrix c;
   rep(i,MAX)
   rep(j,MAX)
   {
     c.m[i][j] = 0;
     rep(k,MAX) c.m[i][j] += (a.m[i][k] * b.m[k][j])%(mod);
     c.m[i][j] %= (mod);
   }
   return c;
}
Matrix quickpow(ll n, Matrix P)
{
    Matrix m = P, b = I;
    while (n &gt;= 1)
    {
        if (n &amp; 1)
        b = matrixmul(b,m);
        n = n &gt;&gt; 1;
        m = matrixmul(m,m);
    }
    return b;
}
void data(){
   freopen("data.in","r",stdin);
   freopen("data.out","w",stdout);
}
int main()
{
    ll a,b,n,m;
    //data();
    while(~scanf("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;a,&amp;b))
    {   
        Matrix T1,T2,T;
        Matrix P1 = {2,1,3,1,0,0,0,0,1};
        Matrix P2 = {5*8,4*8+7,6*8+9,5,4,6,0,0,1};
        T1=quickpow((m-2),P1);
        T2=quickpow(1LL*n-1,matrixmul(T1,P2));
        T=matrixmul(T2,T1);
        Matrix tmp={b%mod,0,0,a%mod,0,0,1,0,0};
        T=matrixmul(T,tmp);
        printf("%lld\n",T.m[0][0]%mod); 
    }
    return 0; 
}
</code></p>

<h2 id="g-httpacmswjtueducnjudgeonlineshowproblemproblemid2179">G <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2179">你是一个好人</a></h2>

<p>概率DP，我们假设<code>dp[i][j]</code>表示前i次表白收集了j张不同卡的概率，那么很明显:
<code>i==1,j==1</code>时 <code>dp[1][1] = 1</code>;<br />
<code>i&lt;j </code>,  <code>dp[i][j] = 0;</code>(一共都不到j张，怎么收集) <br />
那么<code>dp[i+1][j] = dp[i][j]*(j/n)+dp[i][j-1]*(n-(j-1))/n</code>;
第一个表示第<code>i+1</code>收集的与之前的<code>j</code>张是一样的，第二个表示第<code>i+1</code>次收集的与前<code>j-1</code>个不同，那么就就多收集了一个，变成<code>j</code>个。</p>

<p><code>
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cctype&gt;
#include &lt;ctime&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#define SQR(x) ((x)*(x))
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); --i)
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define pow2(n) (1&lt;&lt;(n))
#define pi acos(-1)
#define eps 0.00000001
#define lg(n) log10((n)*1.0)
#define MaxN  1000000
#define mod 1000000007
#define ll long long
#define typed int
using namespace std;
void data(){
   freopen("data.in","r",stdin);
   freopen("data.out","w",stdout);
}
//fast read
void RD(int &amp;a) {
    int value = 0, s = 1;
    char c;
    while ((c = getchar()) == ' ' || c == '\n');
    if (c == '-') s = -s; else value = c-48;
    while ((c = getchar()) &gt;= '0' &amp;&amp; c &lt;= '9')
        value = value * 10 + c - 48;
    a = s * value;
}
void RD(int &amp;a,int &amp;b){
    RD(a),RD(b);
}
void RD(int &amp;a,int &amp;b,int &amp;c){
    RD(a),RD(b),RD(c);
}
double dp[101][2002];
double gao(int n,int m){
     memset(dp,0,sizeof(0));
     dp[0][0]=1.0;
     repd(i,n)repf(j,i,m) dp[i][j]=dp[i-1][j-1]*(n-i+1)/n+dp[i][j-1]*i/n; 
     return dp[n][m];
}
int main(){
   //data();
   int t,n,m;
   RD(t);
   rep(i,t){
      RD(n,m);
      if(m&lt;n)printf("%.6lf\n",0);
      else printf("%.6lf\n",gao(n,m));
   }
   return 0;
}
</code></p>

<h2 id="h-httpacmswjtueducnjudgeonlineshowproblemproblemid2180">H <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2180">最萌身高差</a></h2>

<p>此题为树状数组的 YY 题。。。<br />
首先我们考虑若 β 固定的情况，那么根据同模的性质。。如果 <code>a%p == b%p</code> 那么 <code>|a-b| = k * p</code><br />
这样预处理一下，只要找到模相同的个数，就能知道有多少组了。。此题 β 很小，那么我们维护各个余数的前缀和就可以求个分别余数的区间和了。。。，因为此题要求支持修改，那么我们就使
用树状数组（如果你还不会，那么赶紧学起吧）就可以满足要求了。。、、 <br />
关键是怎么去修改更新；修改了一个数，我们需要一增一减，余数为 a% β 的减一， (a + p)% β 的加 1.. 这样就可以很好的查找和维护了。。 </p>

<p>β不一样？ 但是β很小啊，我们再增加一维？这么做会MLE，那么我们离线处理每个β跑一次就好了。</p>

<p>```
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <climits>
#include <cctype>
#include <ctime>
#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>
#include <set>
#include &lt;map&gt;
#include <stack>
#define SQR(x) ((x)*(x))
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); --i)
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define pow2(n) (1&lt;&lt;(n))
#define pi acos(-1)
#define eps 0.00000001
#define lg(n) log10((n)*1.0)
#define MaxN  200000
#define mod 13041290
#define mod2 1000000009
#define mod3 1000007
#define md(x) (((x)%mod+mod)%mod)
#define inf 2147483647
#define inf2 0x7fffffffffffffff
#define ll long long
#define typed int
using namespace std;
void data(){
   freopen("data.in","r",stdin);
   freopen("data2.out","w",stdout);
}
int C[10][MaxN]={0};
int n,m;
int read(int k,int i){
  int sum=0;
  for(;k;k-=(k&amp;-k)) sum += C[i][k];
  return sum;
}
void update(int k,int p,int i){
    for(;k&lt;=n;k+=(k&amp;-k)) C[i][k] += p;
}
//fast read
void RD(int &amp;a) { 
    int value = 0, s = 1; 
    char c;
    while ((c = getchar()) == ' ' || c == '\n');
    if (c == '-') s = -s; else value = c-48;
    while ((c = getchar()) &gt;= '0' &amp;&amp; c &lt;= '9')
        value = value * 10 + c - 48;
    a = s * value;
}
int B[MaxN],A[MaxN];
int l[MaxN],r[MaxN],beta[MaxN];
int q[MaxN];
ll ans[MaxN];
int used[11];
int Q,a,p,m,l1,r1,beta1;
void gao(){
  memset(used,0,sizeof(used));
  rep(i,n) RD(A[i]);
  int len=0,t=0;
  rep(i,m){
      RD(Q);
    if(Q==1)RD(a),RD(p),l[len]=a,r[len]=p,q[len++]=-1;
    else{
         RD(l1),RD(r1),RD(beta1);
         l[len]=l1,r[len]=r1,beta[len]=beta1;
         used[beta1]=1,q[len++]=t++;
       if(beta1==1){ 
        ll ttt=r1-l1+1; 
        ans[q[len-1]]=ttt*(ttt-1)/2%mod;
       }
     }
  }
}
int main(){
  //data();
  while(~scanf("%d%d",&amp;n,&amp;m)){  
     gao();
     repf(k,2,10){
        if(!used[k])continue;
        memset(C,0,sizeof(C));
        rep(i,n) B[i]=A[i],update(i+1,1,A[i]%k);
        rep(i,m){
           if(q[i]==-1){
              update(l[i],-1,B[l[i]-1]%k);
              update(l[i],1,(B[l[i]-1]+r[i])%k);
              B[l[i]-1]+=r[i];
              continue;
           }
           if(beta[i]!=k)continue;
           ll sum=0;
           rep(j,beta[i]){
               ll tp = read(r[i],j) - read(l[i]-1,j);
               sum += tp*(tp-1)/2;
               sum %=mod;
           }
           ans[q[i]]=sum%mod;
        } 
     }
     rep(i,t) printf("%lld\n",ans[i]%mod);
  }
  return 0;
}</stack></set></vector></queue></iostream></algorithm></ctime></cctype></climits></cmath></cstring></cstdlib></cstdio></p>

<p>```</p>

<h2 id="i-missinghttpacmswjtueducnjudgeonlineshowproblemproblemid2181">I <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=2181">Missing教大家画矩形</a></h2>

<p>模拟题目，确定一个矩形只需要对角线确定，
所以找出最小，最大的x值和y值就行了
题目虽然简单，但是如果写法不好，也会被坑~
(此题来自于Missing)</p>

<p>```
//Draw A Rectangle
//Author: _missing
// 模拟题，确定一个矩形只需要对角线确定，
// 所以找出最小，最大的x值和y值就行了
// 题目虽然简单，但是如果写法不好，也会被坑~
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
void draw(int x1, int y1, int x2, int y2) {
    for (int i = 0; i &lt; x1; ++i) puts("");
    for (int i = x1; i &lt;= x2; ++i) {
        for (int j = 0; j &lt; y1; ++j) putchar(' ');
        for (int j = y1; j &lt;= y2; ++j)
            if (i == x1 || i == x2) putchar('*');
            else if (j == y1 || j == y2) putchar('*');
            else putchar(' ');
        putchar('\n');
    }
}
int main() {
    //freopen("data2.in", "r", stdin);
    //freopen("data2.out", "w", stdout);
    int T, ncase = 0, N;
    while (~scanf("%d", &amp;T)) {
        while (T--) {
            int x[4], y[4], minx = 100, maxx = -1, miny = 100, maxy = -1;
            int ok = 1;</algorithm></cstring></cstdio></iostream></p>

<pre><code>        scanf("%d", &amp;N);
        for (int i = 0; i &lt; N; ++i) scanf("%d %d", x+i, y+i);
        for (int i = 0; i &lt; N; ++i) {
            minx = min(minx, x[i]);
            maxx = max(maxx, x[i]);
            miny = min(miny, y[i]);
            maxy = max(maxy, y[i]);
        }
        if (minx == maxx || miny == maxy) ok = 0;
        for (int i = 0; ok &amp;&amp; i &lt; N; ++i) {
            if ((x[i] == minx || x[i] == maxx) &amp;&amp;
                (y[i] == miny || y[i] == maxy)) continue;
            ok = 0;
        }

        printf("Case #%d:\n", ++ncase);
        if (!ok) { puts("None"); continue; }
        draw(minx, miny, maxx, maxy);
    }
}
return 0; } ```
</code></pre>

<p>以上题目均为过测试数据的程序，不保证程序完全正确无误。 3Q</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bestcode #11 div2]]></title>
    <link href="http://www.UnkelTao.com/blog/2014/09/29/bestcode-number-11-div2/"/>
    <updated>2014-09-29T04:54:35+01:00</updated>
    <id>http://www.UnkelTao.com/blog/2014/09/29/bestcode-number-11-div2</id>
    <content type="html"><![CDATA[<p>博客还是要不定期更新下才行，表示存活。<br />
~~昨天晚上做了杭电的best coder,div2果然还是比较适合我这种弱渣的，都可以做。最后1004出题人实在太恶意了，故意卡内存，MLE到死，1002坑死了一堆人，最后hack了6个（悲催的是自己想到数据了写错了一个字母，自己最后也挂掉了）。<br />
<strong>题解间下面:</strong><br />
<!-- more -->  </p>

<h3 id="httpacmhdueducnshowproblemphppid5054"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5054">1001</a></h3>
<p>签到题，没什么可说的，判断<code>2*x==n&amp;&amp;2*y==m</code>就行了  </p>

<p>```
int main(){
   //data();</p>

<p>int m,n,x,y;</p>

<p>while(~scanf(“%d%d%d%d”,&amp;n,&amp;m,&amp;x,&amp;y)){
      if(x<em>2==n&amp;&amp;y</em>2==m) cout«“YES”«endl;
      else cout«“NO”«endl;
   }
   return 0;
}
```  </p>

<h3 id="httpacmhdueducnshowproblemphppid5055"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5055">1002</a></h3>

<p><strong>题意:</strong> 给你一堆0~9的数字，让你把他们组合成一个满足条件的最大的数:  </p>

<ul>
  <li>木有前导0  </li>
  <li>最后一个必须是奇数  </li>
</ul>

<p>如果没有满足条件的，输出-1。
**解法:  ** 贪心，选一个最小的奇数放最后，然后从大到小输出剩余的数就行了，注意判断无解的情况。<br />
一些特殊数据  </p>

<blockquote>
  <p>5<br />
1 0 0 0 0<br />
out:-1<br />
1<br />
1<br />
out:1<br />
1<br />
0<br />
out:0  </p>
</blockquote>

<p>```
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
void RD(int &amp;a) { 
    int value = 0, s = 1; 
    char c;
    while ((c = getchar()) == ‘ ‘ || c == ‘\n’);
    if (c == ‘-‘) s = -s; else value = c-48;
    while ((c = getchar()) &gt;= ‘0’ &amp;&amp; c &lt;= ‘9’)
        value = value * 10 + c - 48;
    a = s * value;
}
int res[10];
int main(){
   //data();</p>

<p>int n,a;
   while(~scanf(“%d”,&amp;n)){
      int fg=0,fg2=0,mi=11;
      memset(res,0,sizeof(res));
      rep(i,n){ 
         RD(a);
         if(a&amp;1){ fg++;if(mi&gt;a)mi=a;} 
         res[a]++; 
      }<br />
      if(fg==0||(n&gt;1&amp;&amp;res[0]==n-1)){printf(“-1\n”);}
      else{</p>

<pre><code>     for(int i=9;i&gt;=0;i--){
        if(i==mi) rep(j,res[i]-1)printf("%d",i);
        else rep(j,res[i]) printf("%d",i);
        
     }
     printf("%d\n",mi);
  }    }
</code></pre>

<p>return 0;
}
```  </p>

<h3 id="httpacmhdueducnshowproblemphppid5056"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5056">1003</a></h3>

<p>**题意： ** 给你一个只包含小写字母的字符串，问你相同字母不超过k个的子串有多少种。<br />
**解法:  ** 简单的dp吧对于某个i位置，找到该字母的第前k个相同字母的位置(不足k,就在起始位置)，同时维护前i-1的位置最远可以向前的位置。  </p>

<p>```
void RD(int &amp;a) { 
    int value = 0, s = 1; 
    char c;
    while ((c = getchar()) == ‘ ‘ || c == ‘\n’);
    if (c == ‘-‘) s = -s; else value = c-48;
    while ((c = getchar()) &gt;= ‘0’ &amp;&amp; c &lt;= ‘9’)
        value = value * 10 + c - 48;
    a = s * value;
}</p>

<p>int cnt[27];
vector<int> mark[26];
char str[100100];
int main(){
   //data();</int></p>

<p>int T,n,a,k;
   RD(T);</p>

<p>while(T–){
        for(int i=0;i&lt;26;i++){ mark[i].clear();cnt[i]=0;}        <br />
     scanf(“%s”,str);
     RD(k);
     int len=strlen(str);
     ll res=1LL;
     mark[str[0]-‘a’].push_back(0);
     cnt[str[0]-‘a’]++;
     int cur=-1;
     for(int i=1;i&lt;len;i++)
     {   int tp=str[i]-‘a’;</p>

<pre><code>     if(cnt[tp]&lt;k) res+=(i-cur);
     else{cur=max(cur,mark[tp][cnt[tp]-k]); res +=(i-cur);}
     //cout&lt;&lt;tp&lt;&lt;"  "&lt;&lt;cnt[tp]&lt;&lt;"  "&lt;&lt;k&lt;&lt;"   "&lt;&lt;res&lt;&lt;endl;
     cnt[tp]++;
     mark[tp].push_back(i);
 }
 cout&lt;&lt;res&lt;&lt;endl;    }
</code></pre>

<p>return 0;
}
```</p>

<h3 id="httpacmhdueducnshowproblemphppid5057"><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5057">1004</a></h3>

<p><strong>题意:</strong> 给你一串数字，两种操作  </p>

<ul>
  <li>S x y: 将第x个数变为y  </li>
  <li>Q l r d p: 查询[l,r]区间内，第d位数字为p的数有多少个。  </li>
</ul>

<p>**解法: **一开始利用树状数组开了一个C[d][p][MaxN]的数组来维护第d位为p的一个区间和，结果出题人恶意的卡内存，不断的MLE，姿势不够，怎么优化内存都不行，有人说用无符号short型，但是n最大10^6，会溢出。最后改成离线算法，只开C[p][MaxN]的数组来维护某一位为p的区间和，然后预存所有操作，跑10遍，每一遍对应一位。这样内存就很随意了。 <br />
<img src="http://unkeltao.qiniudn.com/wailian%2Fhdudiv211.png" alt="" /><br />
都是泪~</p>

<p>```
#define MaxN 110000
int  C[11][MaxN]={0};
int n,n2,m;
int read(int k,int i){
    int sum=0;
    if(k&lt;=0) return 0;
    for(;k;k-=(k&amp;-k)) sum += C[i][k];
    return sum;
}</p>

<p>void update(int k,int p,int i){
    for(;k&lt;=n;k+=(k&amp;-k)) C[i][k] += p;
}
void RD(int &amp;a) { 
    int value = 0, s = 1; 
    char c;
    while ((c = getchar()) == ‘ ‘ || c == ‘\n’);
    if (c == ‘-‘) s = -s; else value = c-48;
    while ((c = getchar()) &gt;= ‘0’ &amp;&amp; c &lt;= ‘9’)
        value = value * 10 + c - 48;
    a = s * value;
}
int CC[MaxN],A[MaxN];
int p[11];
int T,i,j,a[MaxN],b[MaxN],l[MaxN],r[MaxN],cnt[MaxN],tp1,tp2;
int ans[MaxN];
int mx[11];
char Q[3];
int main(){
   // data();</p>

<pre><code>RD(T);
p[1]=1;
for(i=2;i&lt;=10;i++) p[i]=p[i-1]*10;
while(T--){
   RD(n);
   RD(m);        

   for(i=0;i&lt;n;i++){ 
        RD(A[i]);
        //cout&lt;&lt;A[i]&lt;&lt;endl;
   }
   for(int i=0;i&lt;11;i++)mx[i]=n;
   for(i=0;i&lt;m;i++){
      scanf("%s",Q);
         if(Q[0]=='S'){
         cnt[i]=0;
           RD(a[i]);RD(b[i]);
      }else{
           RD(l[i]);RD(r[i]);RD(a[i]);RD(b[i]);cnt[i]=1;
           mx[a[i]]=i;
      }
      
   }
   
   for(int i=1;i&lt;=10;i++)
   {
         memset(C,0,sizeof(C));
         for(j=0;j&lt;n;j++){
            n2 = (A[j]/p[i])%10;
            update(j+1,1,n2);
            CC[j]=A[j];
         }   
        for(int j=0;j&lt;m;j++){
           // if(j&gt;mx[i]) break;
            if(!cnt[j]) {
                tp1=(CC[a[j]-1]/p[i])%10;
                tp2=(b[j]/p[i])%10;
                if(tp1==tp2) continue;
               {update(a[j],-1,tp1); update(a[j],1,tp2);}
               CC[a[j]-1]=b[j];
            }else if(a[j]==i){
                ans[j] = read(r[j],b[j])-read(l[j]-1,b[j]);
            }
        }
   }
   
   for(i=0;i&lt;m;i++){
      if(cnt[i])  printf("%d\n",ans[i]);
   }                            
} } ```
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces #238 (Div.1 AB)]]></title>
    <link href="http://www.UnkelTao.com/blog/2014/03/23/codeforces-round-number-238-div-dot-1-a/"/>
    <updated>2014-03-23T12:51:37+01:00</updated>
    <id>http://www.UnkelTao.com/blog/2014/03/23/codeforces-round-number-238-div-dot-1-a</id>
    <content type="html"><![CDATA[<p>rating 居然涨了，简直不科学。 <br />
<a href="http://codeforces.com/profile/UnkelTao">弱弱的求个关注:http://codeforces.com/profile/UnkelTao</a>  </p>

<h2 id="a-unusual-producthttpcodeforcescomcontest406problema"><a href="http://codeforces.com/contest/406/problem/A">A. Unusual Product</a></h2>
<p><strong>题意</strong>: 给你一个矩阵，定义了unusual值，类似与矩阵乘法，但是做的与，对应所有Aij&amp;Aji的值再异或，然后你可以对矩阵的一行或者一列进行反转（0变1，1变0）查询则输出Unusual值。<br />
<strong>key</strong>: 我们可以发现，Unusual值其实就是主对角线的值进行异或，跟周围的元素完全没有关系，因为： Aij&amp;Aji,但是Aji又会与Aij，这样等于 <code>（Aij&amp;Aji）^（Aji&amp;Aij）=0 (i!=j)</code>,那么操作一次，结果便会由0变1或者由1变0，不管怎么操作。</p>

<!--more-->

<p>```c++
#include <cstdio>
#include <iostream>
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
using namespace std;
void data(){
   freopen("data.in","r",stdin);
   freopen("data.out","w",stdout);
}
int a[1002][1002],n;
int main(){
    //data();
   scanf("%d",&amp;n);
   rep(i,n)rep(j,n) scanf("%d",&amp;a[i][j]);
   int ans=0;
   for(int i=0;i&lt;n;i++)
   for(int j=0;j&lt;n;j++)
   ans+=a[i][j]*a[j][i];</iostream></cstdio></p>

<p>ans%=2;
   int m;
   scanf(“%d”,&amp;m);
   rep(i,m){
      int a,b;
         scanf(“%d”,&amp;a);
         if(a==3) printf(“%d”,ans);
         else {scanf(“%d”,&amp;b); ans=1-ans;}    <br />
   }
   printf(“\n”);</p>

<p>return 0;
}
```</p>

<h2 id="b-toy-sumhttpcodeforcescomcontest406problemb"><a href="http://codeforces.com/contest/406/problem/B">B. Toy Sum</a></h2>
<p><strong>题意</strong>: 给你1，2…10^6个数，从中已经选出了其中的n个作为X，让你再挑选出m个作为另外一组Y，要求满足题目给出的公式。<br />
<strong>key</strong>:  我们稍微观察一下公式就会发现，  <code>a- 1 == s-(s+1-a)</code> ; 这样，我们就可以贪心了，如果X中选了a,那么看(s+1-a)被选没，没北选，那么我们便把(s+1-a)选入Y，如果选了，那么我们相当于X得了个s,我们便寻找一组都没被选入X的b和（s+1-b）,肯定可以找到的，因为<code>n&lt;=10^5&lt;=s/2</code>; 这样便可以得出一个可行解。</p>

<p>```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <climits>
#include <cctype>
#include <ctime /></cctype></climits></cmath></cstring></cstdlib></cstdio></p>

<h1 id="include-algorithm">include <algorithm /></h1>
<p>#include <iostream>
#include <queue>
#include <vector>
#include <set>
#include &lt;map&gt;
#include <stack /></set></vector></queue></iostream></p>

<h1 id="define-sqrx-xx">define SQR(x) ((x)*(x))</h1>
<p>#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); –i)
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define pow2(n) (1«(n))
#define pi acos(-1)
#define eps 0.00000001
#define lg(n) log10((n)*1.0)
#define MaxN  1000000
#define mod 1000000007
#define mod2 1000000009
#define mod3 1000007
#define md(x) (((x)%mod+mod)%mod)
#define inf 2147483647
#define inf2 0x7fffffffffffffff
#define ll long long
#define typed int
using namespace std;
void data(){
   freopen(“data.in”,”r”,stdin);
   freopen(“data.out”,”w”,stdout);
}
int kk=1000001;
int a[1000002],n;
int t[1000002],t2[1000002];
int ans[1000002],m=0;
int main(){
   // data();
   memset(a,0,sizeof(a));
   memset(t2,0,sizeof(t2));
   scanf(“%d”,&amp;n);</p>

<p>rep(i,n){scanf(“%d”,&amp;t[i]);a[t[i]]=1;}</p>

<p>int tp=0;
   rep(i,n){
      if(a[kk-t[i]]) tp++;
      else{
          if(!t2[kk-t[i]]) ans[m++]=kk-t[i];
          t2[t[i]]=1;
          t2[kk-t[i]]=1;
      }<br />
   }
   tp/=2;
   for(int i=1;i&lt;kk/2+1;i++){
      if(!tp)break;
      if(!a[i]&amp;&amp;!a[kk-i]){ans[m++]=i;ans[m++]=kk-i;tp–;}        <br />
   }</p>

<p>printf(“%d\n”,m);
   printf(“%d”,ans[0]);
   for(int i=1;i&lt;m;i++)
      printf(“ %d”,ans[i]);
   printf(“\n”);   </p>

<p>return 0;
}
```  </p>

<h3 id="cde">C,D,E实在做不动了。</h3>

<p>PS，顺带写下今天群内学第们训练的题，我是太闲了么。。。囧   </p>

<h2 id="e-matrixhttpacmhusteducnvjudgecontestviewactioncid42652probleme"><a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=42652#problem/E">E Matrix</a></h2>
<p><strong>题意</strong>:  给你一个数字字符串，构造一个2维的矩阵，bij = si*sj; 给你一个范围x,y,z,t,让所有x=&lt;i&lt;=y, z=&lt;j&lt;=t 的bij的和等于a的这样的Group有多少个。 <br />
<strong>key</strong>:  我们不难发现，其实所有区间的和其实可以转化为 <code>(Sx+S(x+1)...Sy)*(Xz+...+St)</code>（展开就能就是b了），那么相当于我们求的是连续的一段的和，和另外连续的一段的和的乘积等于a的个数，那么我们可以用O(n^2)的算法枚举出所有连续子段和,并记录没种可能的个数。    </p>

<ul>
  <li>a=0, 那么判断有多少个连续字段和等于0的，<code> res = cnt[0]\*cnt[0] + 2\*cnt[0]\*cnt[i]\(cnt[i] != 0\)</code>      </li>
  <li>a!=0,那么我们就可以分解a为两个数的乘积， <code>res = cnt[c]\*cnt[d]\*2(c\*d==a) (若c==d不乘以2)</code>    </li>
</ul>

<p>```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <climits>
#include <cctype>
#include <ctime /></cctype></climits></cmath></cstring></cstdlib></cstdio></p>

<h1 id="include-algorithm-1">include <algorithm /></h1>
<p>#include <iostream>
#include <queue>
#include <vector>
#include <set>
#include &lt;map&gt;
#include <stack /></set></vector></queue></iostream></p>

<h1 id="define-sqrx-xx-1">define SQR(x) ((x)*(x))</h1>
<p>#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); –i)
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define pow2(n) (1«(n))
#define pi acos(-1)
#define eps 0.00000001
#define lg(n) log10((n)*1.0)
#define MaxN  1000000
#define mod 1000000007
#define mod2 1000000009
#define mod3 1000007
#define md(x) (((x)%mod+mod)%mod)
#define inf 2147483647
#define inf2 0x7fffffffffffffff
#define ll long long
#define typed int
using namespace std;
void data(){
   freopen(“data.in”,”r”,stdin);
   freopen(“data.out”,”w”,stdout);
}
int cnt[MaxN];
int sum[MaxN],a;
char str[MaxN];
int main(){
    //data();
	while(~scanf(“%d”,&amp;a)){
        scanf(“%s”,str);
		memset(cnt,0,sizeof(cnt));					
		int len = strlen(str);
		sum[0]=0;
		rep(i,len){sum[i+1]=sum[i]+str[i]-‘0’;}
		repf(i,1,len)repf(j,i,len)cnt[sum[j]-sum[i-1]]++;</p>

<pre><code>    ll res=0;
    if(a==0)
	{
	 	res+=1LL*cnt[0]*cnt[0];
		repd(i,sum[len])if(cnt[i]) res+=1LL*cnt[0]*cnt[i]*2; 	
		cout&lt;&lt;res&lt;&lt;endl;
		continue;
	}					
	for(int i=1;i*i&lt;=a;i++)
		if(a%i==0&amp;&amp;a/i&lt;=sum[len]) 
			if(i*i==a) res += 1LL*cnt[i]*cnt[a/i];
			else res += 1LL*cnt[i]*cnt[a/i]*2;					  	
	cout&lt;&lt;res&lt;&lt;endl;	
}
</code></pre>

<p>return 0;
}</p>

<p>```</p>

<h3 id="f---how-far-away-httpacmhusteducnvjudgecontestviewactioncid42652problemf"><a href="http://acm.hust.edu.cn/vjudge/contest/view.action?cid=42652#problem/F">F - How far away ？</a></h3>
<p><strong>题意</strong>:  给你一颗树，查询两个之间的距离(有且只有一条)。   <br />
<strong>key</strong>： 标准解放应该是LCA（最近公共祖先） ，由于查询数目极少，本题只有200，那么很明显赤裸裸的搜索也能过啊，不知道为啥木有学第写。 广搜深搜应该都可以，n比较大，需要cevtor或者邻接表存储。  </p>

<p>```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <climits>
#include <cctype>
#include <ctime /></cctype></climits></cmath></cstring></cstdlib></cstdio></p>

<h1 id="include-algorithm-2">include <algorithm /></h1>
<p>#include <iostream>
#include <queue>
#include <vector>
#include <set>
#include &lt;map&gt;
#include <stack /></set></vector></queue></iostream></p>

<h1 id="define-sqrx-xx-2">define SQR(x) ((x)*(x))</h1>
<p>#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); –i)
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define pow2(n) (1«(n))
#define pi acos(-1)
#define eps 0.00000001
#define lg(n) log10((n)*1.0)
#define MaxN  100000
#define mod 1000000007
#define mod2 1000000009
#define mod3 1000007
#define md(x) (((x)%mod+mod)%mod)
#define inf 2147483647
#define inf2 0x7fffffffffffffff
#define ll long long
#define typed int
using namespace std;
void data(){
   freopen(“data.in”,”r”,stdin);
   freopen(“data.out”,”w”,stdout);
}
int pnt[MaxN],nxt[MaxN],head[MaxN],len;
bool used[MaxN];
int w[MaxN];
int fg,ans,n,m;</p>

<p>int t,e;
void init(){
   len=0;
   memset(head,-1,sizeof(head));
   memset(used,0,sizeof(used));
}
void addeg(int u,int v,int k){
      pnt[len] = v;
      w[len]= k;
      nxt[len] = head[u]; 
      head[u] = len++;
}</p>

<p>void dfs(int u,int cur){
  int v;
  used[u]=1;
  if(fg)return;
  for(int i=head[u];i!=-1;i=nxt[i]){
      v=pnt[i];
      if(v==e){fg=1;ans=cur+w[i];return;}
	  if(fg) break;
      if(!used[v]){
         used[v]=1;        <br />
         dfs(v,cur+w[i]);
      }
  }</p>

<p>}
//读入外挂 
void RD(int &amp;a) { 
    int value = 0, s = 1; 
    char c;
    while ((c = getchar()) == ‘ ‘ || c == ‘\n’);
    if (c == ‘-‘) s = -s; else value = c-48;
    while ((c = getchar()) &gt;= ‘0’ &amp;&amp; c &lt;= ‘9’)
        value = value * 10 + c - 48;
    a = s * value;
}
void RD(int &amp;a,int &amp;b){
    RD(a),RD(b);
}
void RD(int &amp;a,int &amp;b,int &amp;c){
    RD(a),RD(b),RD(c);
}</p>

<p>int main(){
	int T,a,b,k;
	RD(T);
	while(T–){
	   init();		 <br />
       RD(n,m);
	   rep(i,n-1){RD(a,b,k);addeg(a,b,k);addeg(b,a,k);}
	   rep(i,m){
	   	  RD(t,e);
	   	  fg=0;
	   	  memset(used,0,sizeof(used));
		  dfs(t,0);
		  printf(“%d\n”,ans);	 		
	   }
	}
	return 0;
}
```</p>

<h1 id="section">最后祝学第们加油。</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Codeforces Round #237 (Div. 2) ]]></title>
    <link href="http://www.UnkelTao.com/blog/2014/03/21/codeforces-round-number-237-div-2/"/>
    <updated>2014-03-21T04:03:13+01:00</updated>
    <id>http://www.UnkelTao.com/blog/2014/03/21/codeforces-round-number-237-div-2</id>
    <content type="html"><![CDATA[<p>群中看到学第们发的比赛链接，于是又做了一场，结果悲惨。再也不在windows下做比赛了，电脑现在不知道出了啥问题，每次00：16都要自动关机。结果敲完的题没保存，又得重新敲一遍。  </p>

<h3 id="a---valera-and-xhttpcodeforcescomcontest404problema"><a href="http://codeforces.com/contest/404/problem/A">A - Valera and X</a></h3>
<p><strong>题意</strong>： 给你一个矩阵，问你是不是恰好有2种字母，对角线字母一样，非对角线字母一样。<br />
<strong>key</strong>:   模拟  </p>

<!--more-->

<p>```ruby</p>

<p>n = gets.chomp!.to_i
a = Array.new(n) </p>

<p>n.times{|i|
    a[i] = gets.chomp!
}</p>

<p>if n==1
    puts “YES”
    exit
end</p>

<p>x = a[0][0]
b = a[0][1]</p>

<p>if x == b
    puts “NO”
    exit
end<br />
n.times { |i|<br />
    n.times { |j|<br />
        if i==j || (i+j==n-1)
            if a[i][j] != x
                puts “NO”
                exit
            end
        else
             if a[i][j] != b
                puts “NO”
                exit
            end
        end
    }
}</p>

<p>puts “YES”</p>

<p>```</p>

<h2 id="b---marathonhttpcodeforcescomcontest404problemb"><a href="http://codeforces.com/contest/404/problem/B">B - Marathon</a></h2>
<p><strong>题意</strong>:  给你一个a*a的正方形，从(0,0)出发，沿边线逆时针行走，走n次，每次走d的距离，输出每次行走后的坐标。</p>

<p><strong>key</strong>:   模拟题，注意精度就好。</p>

<p>```ruby<br />
eps = 1e-5
a,d = gets.chomp!.split.map { |e|  e.to_f}
n =gets.chomp!.to_i
cur_x=0.00
cur_y=0.00
pp=0.00</p>

<p>n.times {
	if cur_y &lt;= eps
		pp = cur_x	
	elsif a-cur_x &lt;= eps
		pp = a + cur_y
	elsif a-cur_y &lt;= eps
		pp = a<em>3 -cur_x	
	else
		pp = a</em>4 -cur_y
	end	
	pp +=d;
	t= (pp/a).floor
	pp -= 1.0<em>t</em>a;
	case t%4
	when 0
		cur_x=pp
		cur_y=0
	when 1
		cur_x=a
		cur_y=pp
	when 2
		cur_x=a-pp
		cur_y=a
	when 3
		cur_x=0
		cur_y=a-pp
	end
	printf(“%.8f %.8f\n”,cur_x,cur_y)
}
```  </p>

<h2 id="c---restore-graphhttpcodeforcescomcontest404problemc"><a href="http://codeforces.com/contest/404/problem/C">C - Restore Graph</a></h2>
<p><strong>题意</strong>:  给你一个无向无子环的图，告诉你所有点到某一个选取的点的距离的矩阵d,问你能不能修复出满足条件的原图，其中一个点最多能够连接k条边。</p>

<p><strong>key</strong>:  首先d中肯定只有一个0，并且该点就是选取的点。否则肯定不存在。 对d进行排序，一条边一条边的修复模拟即可，注意满足每个点连接的边不能超过k个。 </p>

<p>```ruby</p>

<table>
  <tbody>
    <tr>
      <td>n,k = gets.chomp!.split.map {</td>
      <td>e</td>
      <td>e.to_i}</td>
    </tr>
  </tbody>
</table>

<p>D = gets.chomp!.split.map {|e| [e.to_i,0]}
flag = 0
n.times { |i| 
    D[i][1]=i+1
    if D[i][0] == 0
        flag += 1
    end
}
if flag != 1
    p -1
    exit
end</p>

<p>D.sort!
b = Array.new(2<em>n)
e = Array.new(2</em>n)
l=0
f=0
t=1
while t&lt;n 
    if f==1 
        k -= 1 
    end
    if D[t].first!= (D[f].first+1) 
        puts “-1” 
        exit 
    end
    p=k
    i = t
    while i&lt;n
        break if D[i].first!=D[t].first
        if(p==0) 
            f +=1
            p=k 
        end
        if(p==0)<br />
            puts(“-1”) 
            exit 
        end
        p -= 1
        if(f==t)<br />
            puts(“-1”) 
            exit 
        end
        b[l]=D[f][1];
        e[l]=D[i][1];
        l+=1;i+=1;
    end
    f=t;
    t=i;
end</p>

<p>p l
l.times { |i|<br />
    puts “#{b[i]} #{e[i]}”
}
```  </p>

<h2 id="d---minesweeper-1dhttpcodeforcescomcontest404problemd"><a href="http://codeforces.com/contest/404/problem/D">D - Minesweeper 1D</a></h2>
<p><strong>题意</strong>: 给你一个1<em>n的地雷图，0表示左右都没有地雷，1表示左右共有1个雷，2表示左右都是雷，</em>表示该点是雷，？表示该点未知，求有多少种合法的方案。  </p>

<p><strong>key</strong>: DP,<code>dp[i][0]表示i点是0的方案数，dp[i][1]表示i点是1的方案数，dp[i][2]表示该点是雷的方案数</code>，其中1可以转化为0，2可以转化为1。 因为“<em>1”的话后面肯定不会是雷，那么变成0的方案数，如果是”01”或“11”的话，后面肯定是雷，保持1不动，”</em>2”的话后面肯定是雷。<br />
<strong>转移方程见代码</strong>  </p>

<p>```ruby 
s = gets.chomp!
mods = 1000000007
dp = [[0,0,0],[0,0,0]]</p>

<p>len =s.size
cur =0;nxt=1;</p>

<p>dp[cur][0]=dp[cur][1]=1</p>

<p>for i in 0…len
	case s[i]
	when ‘0’
		dp[nxt][0]=dp[cur][0]
	when ‘1’
		dp[nxt][1]= dp[cur][0]
		dp[nxt][0]= dp[cur][2]
	when ‘2’
		dp[nxt][1]=dp[cur][2]
	when ‘*’
		dp[nxt][2]= (dp[cur][1]+dp[cur][2])%mods
	when ‘?’
		dp[nxt][1]= (dp[cur][2]+dp[cur][0])%mods
		dp[nxt][0]= (dp[cur][0]+dp[cur][2])%mods
		dp[nxt][2]= (dp[cur][1]+dp[cur][2])%mods
	end
	cur = nxt
	nxt = cur==0?1:0
	dp[nxt] = [0,0,0]
end</p>

<p>puts “#{(dp[cur][0]+dp[cur][2])%mods}” 
```  </p>

<h2 id="e---maze-1dhttpcodeforcescomcontest404probleme"><a href="http://codeforces.com/contest/404/problem/E">E - Maze 1D</a></h2>
<p><strong>题意</strong>: 题意真是难读,大概就是机器人会左右移动，但是如果前面的点是障碍点的话他就不会向前进忽略这次移动，问在设置最少障碍点的情况下能够使得机器人最后停下的位置是以前没有走过的。 问这样的设置方案数有多少个（在障碍点最少的情况下）。</p>

<p><strong>key</strong>: 二分+枚举。   </p>

<ul>
  <li>首先我们可以确定，如果不加障碍点他最后停留的位置只走过一次的话，那么方案数肯定是1。   </li>
  <li>最多设置一个障碍点，如果一个障碍点不能满足情况，再多的障碍点也没用。  </li>
  <li>如果i点可以是障碍点，那么<code>(0,i]</code>的点都可以是障碍点，同理-i是障碍点，<code>[-1,0)</code>都可以是障碍点。  </li>
</ul>

<p>有了这样的理解，那么遍可以2分来判断最大的i点是不是可以为障碍点了，判断方法模拟就可以了。<br />
<strong>(ruby跑的太慢，TLE了，囧RZ，C++可以AC)</strong>  </p>

<p><strong>ruby代码</strong></p>

<p>```ruby
#TLE 代码
$s = gets.chomp!
$fg = 2
$len = $s.size
$mods = $len+7
$vis = Array.new((5*$mods))
def Judge(k)</p>

<pre><code>$fg += 1
pos = $mods + 100
k += pos
$vis[pos] = $fg
$len.times { |i|  
	if $s[i].chr=='R' and pos+1 !=k
		pos += 1
		# p 111111111111
	elsif $s[i].chr=='L' and pos-1 != k
		pos -= 1
		# p 222222222222
	end
	if i==$len-1
		# puts "b:"
		# p $vis[pos]
		# p pos 
		# p $fg
		return $vis[pos] != $fg
	end
	$vis[pos] = $fg
} end
</code></pre>

<p>if Judge($mods+300)
	p 1
	exit
end</p>

<p>res = 0
l = 1
r=$len</p>

<p>if Judge(1)
	while l&lt;r
		mid = ((l+r+1)/2).floor
		if Judge(mid)
			l = mid
		else
			r =mid -1
		end
	end
	res += l
end</p>

<p>l = 1
r=$len</p>

<p>if Judge(-1)
	while l&lt;r
		mid = (l+r+1)/2
		if Judge(-1*mid)
			l = mid
		else
			r =mid -1
		end
	end
	res += l
end</p>

<p>p res
```</p>

<p><strong>c++代码</strong>  </p>

<p>```c++
char str[MaxN];
int fg=2,len;
int vis[5*MaxN];</p>

<p>bool Judge(int k){
   fg++;
   int pos=1e6+10;
   k+=pos;
   vis[pos] = fg;
   // printf(“%d %d %d\n”, fg,pos,k);
   rep(i,len){
   	  if(str[i]==’R’&amp;&amp;pos+1!=k) pos++;
   	  if(str[i]==’L’&amp;&amp;pos-1!=k) pos–;
   	  if(i==len-1){
   	  	// printf(“ans %d  %d %d\n”, vis[pos],fg,pos);
   	  	return vis[pos] != fg;
   	  }
   	  vis[pos] = fg;
   }	
}</p>

<p>int main()
{
	while(~scanf(“%s”,str)){
		len = strlen(str);
		memset(vis,0,sizeof(vis));</p>

<pre><code>	if(Judge(1e6+200)){
		printf("1\n");
		return 0;
	}

	ll res = 0;
	int l=1,r=len,mid;
	if (Judge(1))
	{
		while(l&lt;r){
			mid = (l+r+1)/2;
			if(Judge(mid)) l=mid;
			else r=mid-1;
		}
		res += l;
	}

	if (Judge(-1))
	{
		l=1,r=len,mid;
		while(l&lt;r){
			mid = (l+r+1)/2;
			if(Judge(-mid)) l=mid;
			else r=mid-1;
		}
		res += l;			
	}
	cout&lt;&lt;res&lt;&lt;endl;
}	
return 0; }
</code></pre>

<p>```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MemSQL start]]></title>
    <link href="http://www.UnkelTao.com/blog/2013/08/04/memsql-start/"/>
    <updated>2013-08-04T13:13:34+01:00</updated>
    <id>http://www.UnkelTao.com/blog/2013/08/04/memsql-start</id>
    <content type="html"><![CDATA[<p>【测试代码】</p>

<p>昨晚的CF略晚~~而且提示说div2的少年们，你们很可能会爆0~~~</p>

<p>于是赤裸裸的去了，然后悲催的爆0了</p>

<p>只看了A、B两题~~A题觉得挺简单的，敲了个2分交上去过了Pass，想了想B觉得没有想法就睡觉了。。。
<!--more-->
早上一起洗个澡吃完早餐一看~~WA了~~然后看了下代码，我去，尼玛有一行特判输出没改，直接注释掉没用的特判就过了</p>

<p>说说A题吧，题意大概是一串字符串，求一个长度为k的子串，是的用最少的该子串来构成源串，你可以使用子串的其中任意个字符按照你想要的方式排序拼接,输出需要的最少个数和该k子串。</p>

<p>解法：数据那么弱，统计下源串每个字母的个数，直接暴力匹配从1个到(n+k-1)/k个能否拼成源串就好,写的2分,也过了.</p>

<p><code>c++ 
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cctype&gt;
#include &lt;ctime&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#define SQR(x) ((x)*(x))
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); --i)
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define pow2(n) (1&lt;&lt;(n))
#define pi acos(-1)
#define eps 0.00000001
#define lg(n) log10((n)*1.0)
#define MaxN  1000000
#define mod 10e+7
#define ll long long
#define typed int
using namespace std;
void data(){
   freopen("data.in","r",stdin);
   freopen("data.out","w",stdout);
}
char s[1100];
int su[27];
int k;
int jd(int n){
   int cnt=0;
   rep(i,26){
       cnt+=(su[i]+n-1)/n;
   } 
   if(cnt&lt;=k) return 1;
   else return 0;
}
void pt(int n){
 //  cout&lt;&lt;"pt"&lt;&lt;endl;   
   cout&lt;&lt;n&lt;&lt;endl;    
   string ss="";
   int cnt=0;
   rep(i,26){
      rep(j,(su[i]+n-1)/n){ ss+=(i+'a');cnt++;}
   }
   cout&lt;&lt;ss;
   rep(i,k-cnt)cout&lt;&lt;'a';
   cout&lt;&lt;endl;
}
void bit(int l,int r){
     while(l&lt;r){
     int mid=(l+r)/2;
     int kk=jd(mid);
       if(kk&gt;0) r=mid;
       else l=mid+1;    
     }
     pt(l);
}
 
int main(){
   while(cin&gt;&gt;s&gt;&gt;k){
     rep(i,26) su[i]=0;
     rep(i,strlen(s))su[s[i]-'a']++;
     int ma=0,cnt=0;
     rep(i,26)if(su[i]){cnt++;ma=max(ma,su[i]);}
     if(k&lt;cnt)cout&lt;&lt;-1&lt;&lt;endl;
     else{
       
         
        //bit((strlen(s)+k-1)/k,ma+1); //2分 
        repd(i,strlen(s)){   //暴力 
           if(jd(i)){pt(i);break;}
        }
     } 
   }        
   return 0;
}
</code></p>

<p>B题一看最长回文子序列，能想到的方法就是2维DP出LCS~~可是源串长度为50000，2维DP肯定挂~~早上起来，顺带看了一眼，发现一个条件，回文最长为100（大于100输出100的就行）,这个想了下，就好搞了.一共26字母，说明在2600个字母序列里面肯定会产生回文长度至少是100的。。</p>

<p>这样超过长度2600的就可以直接DP前2600个字母就行了~~~然后就是模板题了~~~真是弱爆了~~</p>

<p><code>c++ 
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;climits&gt;
#include &lt;cctype&gt;
#include &lt;ctime&gt;
 
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
 
#define SQR(x) ((x)*(x))
#define rep(i, n) for (int i=0; i&lt;(n); ++i)
#define repd(i,n)  for(int i=1;i&lt;=(n);++i)
#define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)
#define reps(i, a, b) for (int i=(a); i&gt;=(b); --i)
#define PB push_back
#define MP(A, B) make_pair(A, B)
#define pow2(n) (1&lt;&lt;(n))
#define pi acos(-1)
#define eps 0.00000001
#define lg(n) log10((n)*1.0)
#define MaxN  50000
#define mod 10e+7
#define ll long long
#define typed int
using namespace std;
void data(){
   freopen("data.in","r",stdin);
   freopen("data.out","w",stdout);
}
int dp[2620][2620];
char c[MaxN+100],a[2620],b[2620];
int k[2620][2620];
int cnt[27];
void LCS(int len){
     int i, j;
      rep(i,len+1){ dp[i][0]=dp[0][i]=0;}
      repd(i,len)
        repd(j,len)
        {
            if(a[i]==b[j]){
                k[i][j]=0;
                dp[i][j]=1+dp[i-1][j-1];  
            }
            else if(dp[i-1][j]&gt;=dp[i][j-1]){
                k[i][j]=1;
                dp[i][j]=dp[i-1][j]; 
            }
            else{
                 k[i][j]=-1;
                 dp[i][j]=dp[i][j-1];
            }         
        } 
}
char st[2610];
int num;
void pt(int m,int n){
   if(n==0||m==0) return ;
   if(k[m][n]==0){
     pt(m-1,n-1);
     st[num++]=a[m];
   }
   else if(k[m][n]&gt;0) pt(m-1,n);
   else pt(m,n-1);  
}
int main(){
    //data();
    while(~scanf("%s",c+1)){                            
     int len=strlen(c+1);
     num=0;
     bool fg=1;
     repd(i,len){
         cnt1-'a']++;
         if(cnt1-'a']&gt;=100){
           rep(j,100)cout&lt;&lt;c[i];
           cout&lt;&lt;endl;fg=0;break;
         }
     }
     if(!fg)continue;
     if(len&gt;2602) len=2602;
     repd(i,len){a[i]=c[i];b[len+1-i]=c[i];}
     LCS(len);
     pt(len,len);
     if(num&lt;=100)printf("%s\n",st);
     else{
       rep(i,50)cout&lt;&lt;st[i];reps(i,49,0)cout&lt;&lt;st[i]; cout&lt;&lt;endl;  
     }
     
    }           
   return 0;
}
</code></p>

<p>（效果似乎一般）</p>

]]></content>
  </entry>
  
</feed>
