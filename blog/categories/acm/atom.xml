<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ACM | UnkelTao]]></title>
  <link href="http://UnkelTao.github.io/blog/categories/acm/atom.xml" rel="self"/>
  <link href="http://UnkelTao.github.io/"/>
  <updated>2014-02-19T00:01:56+08:00</updated>
  <id>http://UnkelTao.github.io/</id>
  <author>
    <name><![CDATA[UnkelTao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MemSQL start]]></title>
    <link href="http://UnkelTao.github.io/blog/2013/08/04/memsql-start/"/>
    <updated>2013-08-04T20:13:34+08:00</updated>
    <id>http://UnkelTao.github.io/blog/2013/08/04/memsql-start</id>
    <content type="html"><![CDATA[<p>【测试代码】</p>

<p>昨晚的CF略晚~~而且提示说div2的少年们，你们很可能会爆0~~~</p>

<p>于是赤裸裸的去了，然后悲催的爆0了</p>

<p>只看了A、B两题~~A题觉得挺简单的，敲了个2分交上去过了Pass，想了想B觉得没有想法就睡觉了。。。</p>

<!--more-->


<p>早上一起洗个澡吃完早餐一看<del>WA了</del>然后看了下代码，我去，尼玛有一行特判输出没改，直接注释掉没用的特判就过了</p>

<p>说说A题吧，题意大概是一串字符串，求一个长度为k的子串，是的用最少的该子串来构成源串，你可以使用子串的其中任意个字符按照你想要的方式排序拼接,输出需要的最少个数和该k子串。</p>

<p>解法：数据那么弱，统计下源串每个字母的个数，直接暴力匹配从1个到(n+k-1)/k个能否拼成源串就好,写的2分,也过了.</p>

<p>```</p>

<h1>include <cstdio></h1>

<h1>include <cstdlib></h1>

<h1>include <cstring></h1>

<h1>include <cmath></h1>

<h1>include <climits></h1>

<h1>include <cctype></h1>

<h1>include <ctime></h1>

<h1>include <algorithm></h1>

<h1>include <iostream></h1>

<h1>include <queue></h1>

<h1>include <vector></h1>

<h1>include <set></h1>

<h1>include <map></h1>

<h1>include <stack></h1>

<h1>define SQR(x) ((x)*(x))</h1>

<h1>define rep(i, n) for (int i=0; i&lt;(n); ++i)</h1>

<h1>define repd(i,n)  for(int i=1;i&lt;=(n);++i)</h1>

<h1>define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)</h1>

<h1>define reps(i, a, b) for (int i=(a); i>=(b); &mdash;i)</h1>

<h1>define PB push_back</h1>

<h1>define MP(A, B) make_pair(A, B)</h1>

<h1>define pow2(n) (1&lt;&lt;(n))</h1>

<h1>define pi acos(-1)</h1>

<h1>define eps 0.00000001</h1>

<h1>define lg(n) log10((n)*1.0)</h1>

<h1>define MaxN  1000000</h1>

<h1>define mod 10e+7</h1>

<h1>define ll long long</h1>

<h1>define typed int</h1>

<p>using namespace std;
void data(){
   freopen(&ldquo;data.in&rdquo;,&ldquo;r&rdquo;,stdin);
   freopen(&ldquo;data.out&rdquo;,&ldquo;w&rdquo;,stdout);
}
char s[1100];
int su[27];
int k;
int jd(int n){
   int cnt=0;
   rep(i,26){
       cnt+=(su[i]+n-1)/n;
   }
   if(cnt&lt;=k) return 1;
   else return 0;
}
void pt(int n){
 //  cout&lt;&lt;&ldquo;pt&rdquo;&lt;&lt;endl;  
   cout&lt;&lt;n&lt;&lt;endl;   
   string ss=&ldquo;&rdquo;;
   int cnt=0;
   rep(i,26){
      rep(j,(su[i]+n-1)/n){ ss+=(i+&lsquo;a&rsquo;);cnt++;}
   }
   cout&lt;&lt;ss;
   rep(i,k-cnt)cout&lt;&lt;&lsquo;a&rsquo;;
   cout&lt;&lt;endl;
}
void bit(int l,int r){
     while(l&lt;r){
     int mid=(l+r)/2;
     int kk=jd(mid);
       if(kk>0) r=mid;
       else l=mid+1;   
     }
     pt(l);
}
 
int main(){
   while(cin>>s>>k){
     rep(i,26) su[i]=0;
     rep(i,strlen(s))su[s[i]&ndash;&lsquo;a&rsquo;]++;
     int ma=0,cnt=0;
     rep(i,26)if(su[i]){cnt++;ma=max(ma,su[i]);}
     if(k&lt;cnt)cout&lt;&lt;-1&lt;&lt;endl;
     else{
       
         
        //bit((strlen(s)+k-1)/k,ma+1); //2分
        repd(i,strlen(s)){   //暴力
           if(jd(i)){pt(i);break;}
        }
     }
   }       
   return 0;
}
```</p>

<p>B题一看最长回文子序列，能想到的方法就是2维DP出LCS<del>可是源串长度为50000，2维DP肯定挂</del>早上起来，顺带看了一眼，发现一个条件，回文最长为100（大于100输出100的就行）,这个想了下，就好搞了.一共26字母，说明在2600个字母序列里面肯定会产生回文长度至少是100的。。</p>

<p>这样超过长度2600的就可以直接DP前2600个字母就行了<del>然后就是模板题了</del>真是弱爆了~~</p>

<p>```</p>

<h1>include <cstdio></h1>

<h1>include <cstdlib></h1>

<h1>include <cstring></h1>

<h1>include <cmath></h1>

<h1>include <climits></h1>

<h1>include <cctype></h1>

<h1>include <ctime></h1>

<p> </p>

<h1>include <algorithm></h1>

<h1>include <iostream></h1>

<h1>include <queue></h1>

<h1>include <vector></h1>

<h1>include <set></h1>

<h1>include <map></h1>

<h1>include <stack></h1>

<p> </p>

<h1>define SQR(x) ((x)*(x))</h1>

<h1>define rep(i, n) for (int i=0; i&lt;(n); ++i)</h1>

<h1>define repd(i,n)  for(int i=1;i&lt;=(n);++i)</h1>

<h1>define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)</h1>

<h1>define reps(i, a, b) for (int i=(a); i>=(b); &mdash;i)</h1>

<h1>define PB push_back</h1>

<h1>define MP(A, B) make_pair(A, B)</h1>

<h1>define pow2(n) (1&lt;&lt;(n))</h1>

<h1>define pi acos(-1)</h1>

<h1>define eps 0.00000001</h1>

<h1>define lg(n) log10((n)*1.0)</h1>

<h1>define MaxN  50000</h1>

<h1>define mod 10e+7</h1>

<h1>define ll long long</h1>

<h1>define typed int</h1>

<p>using namespace std;
void data(){
   freopen(&ldquo;data.in&rdquo;,&ldquo;r&rdquo;,stdin);
   freopen(&ldquo;data.out&rdquo;,&ldquo;w&rdquo;,stdout);
}
int dp[2620][2620];
char c[MaxN+100],a[2620],b[2620];
int k[2620][2620];
int cnt[27];
void LCS(int len){
     int i, j;
      rep(i,len+1){ dp[i][0]=dp[0][i]=0;}
      repd(i,len)
        repd(j,len)
        {
            if(a[i]==b[j]){
                k[i][j]=0;
                dp[i][j]=1+dp[i-1][j-1]; 
            }
            else if(dp[i-1][j]>=dp[i][j-1]){
                k[i][j]=1;
                dp[i][j]=dp[i-1][j];
            }
            else{
                 k[i][j]=-1;
                 dp[i][j]=dp[i][j-1];
            }        
        }
}
char st[2610];
int num;
void pt(int m,int n){
   if(n==0||m==0) return ;
   if(k[m][n]==0){
     pt(m-1,n-1);
     st[num++]=a[m];
   }
   else if(k[m][n]>0) pt(m-1,n);
   else pt(m,n-1); 
}
int main(){
    //data();
    while(~scanf(&ldquo;%s&rdquo;,c+1)){                           
     int len=strlen(c+1);
     num=0;
     bool fg=1;
     repd(i,len){
         cnt1-&lsquo;a&rsquo;]++;
         if(cnt1-&lsquo;a&rsquo;]>=100){
           rep(j,100)cout&lt;&lt;c[i];
           cout&lt;&lt;endl;fg=0;break;
         }
     }
     if(!fg)continue;
     if(len>2602) len=2602;
     repd(i,len){a[i]=c[i];b[len+1-i]=c[i];}
     LCS(len);
     pt(len,len);
     if(num&lt;=100)printf(&ldquo;%s\n&rdquo;,st);
     else{
       rep(i,50)cout&lt;&lt;st[i];reps(i,49,0)cout&lt;&lt;st[i]; cout&lt;&lt;endl; 
     }
     
    }          
   return 0;
}
```</p>

<p>（效果似乎一般）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回文判断 Hash+线段树]]></title>
    <link href="http://UnkelTao.github.io/blog/2012/12/18/huiwen-hash/"/>
    <updated>2012-12-18T17:14:12+08:00</updated>
    <id>http://UnkelTao.github.io/blog/2012/12/18/huiwen-hash</id>
    <content type="html"><![CDATA[<p>比赛的一道题,一直没时间写.最近空了，继续写写水题。</p>

<!--more-->


<p>题目描述：
Description</p>

<p>Now we have a long long string, and we will have two kinds of operation on it.
C i y: change the ith letter to y;
Q i j: check whether the substring from ith letter to jth letter is a palindrome.
Input</p>

<p>There are multiple test cases.
The first line contains a string whose length is not large than 1,000,000.
The next line contains a integer N indicating the number of operations.
The next N lines each lines contains a operation.
All letters in the input are lower-case.
Output</p>

<p>For each query operation, output &ldquo;yes&rdquo; if the corresponding substring is a palindrome, otherwise output &ldquo;no&rdquo;.</p>

<p>Sample Input
aaaaa
4
Q 1 5
C 2 b
Q 1 5
Q 1 3</p>

<p>Sample Output</p>

<p>yes
no
yes</p>

<p>题意：给你一串字符串~然后有两种操作：Q a b 询问a到b之间的子串是否是回文 ；C i y 将第i个字母变成y</p>

<p>水题，比赛的时候没有写完,
在学妹的提示下，知道了判断回文可以用hash，正反hash相等的子串就是回文;于是再套上线段树来维护区间的hash值.</p>

<p>```</p>

<h1>include<iostream></h1>

<h1>include <cstdio></h1>

<h1>include <cstdlib></h1>

<h1>include <cstring></h1>

<h1>include<algorithm></h1>

<h1>include<cmath></h1>

<h1>define N 1100010</h1>

<h1>define mod 1000000007</h1>

<h1>define ll long long</h1>

<p>using namespace std;</p>

<p>struct Tree
{
   int l;
   int r;
   ll left;
   ll right;  <br/>
};</p>

<p>Tree T[N*2];
char str[N];
int kk[N];</p>

<p>void hashinit(){kk[0]=1; for(int i=1;i&lt;N;i++) kk[i]=kk[i-1]*2%mod;}
Tree cnt(Tree tmp1,Tree tmp2)
{   Tree ans;</p>

<pre><code> ans.l=tmp1.l;
 ans.r=tmp2.r;    
 ans.left=(kk[tmp2.r-tmp2.l+1]*tmp1.left+tmp2.left)%mod;
 ans.right=(kk[tmp1.r-tmp1.l+1]*tmp2.right+tmp1.right)%mod;  
 return ans; 
</code></pre>

<p>}
void init(int i,int l,int r)
{</p>

<pre><code> T[i].l=l;
 T[i].r=r; 
 if(l==r){
    T[i].right=T[i].left=str[l-1]-'a';
    return ;
 }
 init(i&lt;&lt;1,l,(l+r)&gt;&gt;1);
 init(i&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);  
 T[i]=cnt(T[i&lt;&lt;1],T[i&lt;&lt;1|1]);
</code></pre>

<p>}
void update(int i,int k,int w)
{</p>

<pre><code> int ans;
 if(T[i].l==T[i].r){                                      
   if(T[i].l==k)T[i].left=T[i].right=w;          
   return ;                                     
 }

 if(T[i&lt;&lt;1].l&lt;=k&amp;&amp;T[i&lt;&lt;1].r&gt;=k) update(i&lt;&lt;1,k,w);                                 
 if(T[i&lt;&lt;1|1].l&lt;=k&amp;&amp;T[i&lt;&lt;1|1].r&gt;=k)update(i&lt;&lt;1|1,k,w);    
 T[i]=cnt(T[i&lt;&lt;1],T[i&lt;&lt;1|1]);
</code></pre>

<p>}
Tree querry(int i,int l,int r)
{</p>

<pre><code> Tree ans;
 if(T[i].l&gt;=l&amp;&amp;T[i].r&lt;=r)return T[i];                                     
 if(T[i&lt;&lt;1].r&gt;=r)return querry(i&lt;&lt;1,l,r);                                 
 if(T[i&lt;&lt;1|1].l&lt;=l)return querry(i&lt;&lt;1|1,l,r);                                               
 return cnt(querry(i&lt;&lt;1,l,T[i&lt;&lt;1].r),querry(i&lt;&lt;1|1,T[i&lt;&lt;1|1].l,r));
</code></pre>

<p>}
int main()
{</p>

<pre><code>int q,k,a,b;
char qt[2],ch[2];
Tree ans; 
hashinit();
while(~scanf("%s",str)){   
    init(1,1,strlen(str));       
    scanf("%d",&amp;q);
   while(q--){ 
       scanf("%s",&amp;qt);
       if(qt[0]=='C'){
        scanf("%d%s",&amp;k,&amp;ch);
        update(1,k,ch[0]);
       }else{
        scanf("%d%d",&amp;a,&amp;b);
        ans=querry(1,a,b);
        printf("%s\n",ans.right==ans.left?"yes":"no");
       }
   }
}
return 0;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
