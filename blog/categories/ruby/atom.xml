<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | /UnkelTao]]></title>
  <link href="http://www.UnkelTao.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://www.UnkelTao.com/"/>
  <updated>2014-03-11T14:36:38+08:00</updated>
  <id>http://www.UnkelTao.com/</id>
  <author>
    <name><![CDATA[UnkelTao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[codeforce 235]]></title>
    <link href="http://www.UnkelTao.com/blog/2014/03/11/codeforce-235/"/>
    <updated>2014-03-11T14:02:19+08:00</updated>
    <id>http://www.UnkelTao.com/blog/2014/03/11/codeforce-235</id>
    <content type="html"><![CDATA[<p>好久没做CF了，觉得再不做估计以后笔试都过不鸟，于是还得经常做一做。</p>

<p>CF的回滚对我木有影响阿，我已经好久没做了似乎。</p>

<p>这次的DIV2似乎比以前的简单一点。</p>

<h2><a href="http://codeforces.com/contest/401/problem/A">A. Vanya and Cards</a></h2>

<p>送分,大概给你一堆数，问你最少还需要几个绝对值不超过X的数能够让他们的和为0.</p>

<p><code>ruby
n,x = gets.chomp!.split.map { |e|  e.to_i}
sum = gets.split.collect{|x| x.to_i}.inject{|y, x| y += x}
p (sum.abs + x -1)/x
</code></p>

<!--more-->


<h2><a href="http://codeforces.com/contest/401/problem/B">B. Sereja and Contests</a></h2>

<p>模拟题
```ruby
n,k = gets.chomp!.split.map { |e|  e.to_i}
A = Array.new(n) { |i|  0}
k.times {<br/>
   c,d1,d2 =  gets.chomp!.split.map { |e|  e.to_i}
   A[d1-1] = 1
   if d2 != nil</p>

<pre><code> A[d2-1] = 1
</code></pre>

<p>   end
}</p>

<p>mx=0
mi=0
cur=0
(n-1).times do |i|
   if A[i] == 0</p>

<pre><code>    cur += 1
</code></pre>

<p>   else</p>

<pre><code>   mx += cur
   mi += (cur+1)/2
   cur = 0  
</code></pre>

<p>   end<br/>
end</p>

<p>mx += cur
mi += (cur+1)/2
puts &ldquo;#{mi} #{mx}&rdquo;
```</p>

<h2><a href="http://codeforces.com/contest/401/problem/C">C. Team</a></h2>

<p>也是模拟题，给你n个1，m个0，让你给出一种排列，不能有3个1连在一起，不能有两个0连在一起，给出任意一种方案即可，不能则输出-1
```ruby
m,n = gets.chomp!.split.map { |e|  e.to_i}
if n+1 &lt; m</p>

<pre><code>p -1
exit
</code></pre>

<p>elsif (m+1)*2 &lt; n</p>

<pre><code>p -1
exit
</code></pre>

<p>end</p>

<p>if n == m</p>

<pre><code>n.times{printf "10" }
puts ""
</code></pre>

<p>elsif m == n+1</p>

<pre><code>n.times{print "01"}
puts 0
</code></pre>

<p>elsif (m+1)*2 == n</p>

<pre><code>m.times{printf "110"}
puts "11"
</code></pre>

<p>elsif m*2 == n</p>

<pre><code>m.times{print "110"}
puts ""
</code></pre>

<p>else</p>

<pre><code>k = n - 1 - m
(k).times {print "110"}
(m-k).times{print "10"}
puts "1"
</code></pre>

<p>end
```</p>

<h2><a href="http://codeforces.com/contest/401/problem/D">D. Roman and Numbers</a></h2>

<p>暴力+状态压缩。
题意：给你一个不超过18位的数n,和不超过100的m,将n进行重排(改变里面的位置，当然0不能排在最前面)，问有多少个数是m的倍数。
ruby似乎跑的很慢，不幸TLE的，C++可以过</p>

<p>```ruby
n,m = gets.chomp!.split
m = m.to_i
len = n.size
dp = Array.new((1&lt;&lt;len)+2) {Array.new(m+5,0)}
dp[0][0] = 1</p>

<p>(1&lt;&lt;len).times do |i|</p>

<pre><code>m.times { |j|  
    tp = Array.new(20,0)
    len.times{|k|
        t = n[k].chr.to_i
        if i&amp;(1&lt;&lt;k) != 0 || (i==0 &amp;&amp; t==0) || tp[t] !=0 
            next
        end
        tp[t] = 1
        dp[i|(1&lt;&lt;k)][(j*10+t)%m] +=dp[i][j]
    }   
}
</code></pre>

<p>end
p dp[(1&lt;&lt;len)-1][0]
```</p>

<h2><a href="http://codeforces.com/contest/401/problem/E">E. Olympic Games</a></h2>

<p>略难，暂时不会</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Hustoj添加ruby支持]]></title>
    <link href="http://www.UnkelTao.com/blog/2014/03/02/ruby-for-hustoj/"/>
    <updated>2014-03-02T22:33:16+08:00</updated>
    <id>http://www.UnkelTao.com/blog/2014/03/02/ruby-for-hustoj</id>
    <content type="html"><![CDATA[<p>虽然已经不是再搞ACM了，但是算法偶尔还是要练习一下写代码，然后最近学习ruby中，打算用ruby来写写ACM题目也算熟悉ruby，免得不用就忘记了，记得Hustoj是可以支持Ruby的，于是就在我们学校的训练Oj上提交了A+B的Ruby代码：
```ruby
readlines.each{|line|</p>

<pre><code>p line.split.collect{|x| x.to_i}.inject{|y, x| y += x}
</code></pre>

<p>}
```
于是华丽的给了我一个WA~~~正在想怎么可能，想起来服务器上没有装ruby，于是远程到7509的服务器上再ssh到训练oj的服务器(只能内网访问，ping不到外网地址)，将ruby装上。</p>

<p>然后就开始了无止境的RE生涯，简直无情，各种call禁止：</p>

<!--more-->


<p><img src="http://unkeltao.qiniudn.com/img/IMG_ruby_1.png" alt="" /></p>

<p>在hustoj的wiki页面上，终于找到了参考的添加其他<a href="http://code.google.com/p/hustoj/wiki/AddProgrammingLanguage">语言支持的方法</a></p>

<p>其实主要的就是找到所有的call编号，放到数组里面去就行了，ruby对应了两个数组</p>

<p>```rb</p>

<h1>保存为Main.rb</h1>

<p>readlines.each{|line|</p>

<pre><code>p line.split.collect{|x| x.to_i}.inject{|y, x| y += x}
</code></pre>

<p>```</p>

<p>terminal中运行如下命令。</p>

<p><code>sh
strace -ff ruby Main.rb 2&gt;&amp;1|awk -F\( '{print $1}'|sort -u
</code></p>

<p>然后会产生,以access开头，write结束（也有可能是其他）的一些列标志如下：</p>

<p><code>
access
xxx
xxx
write
</code></p>

<p>把这些标志放入如下过程，结尾是0，对应RC数组其他值为-1，结尾为0.
<code>c++
int LANG_RV[256]={SYS_access,SYS_write.....,0};
int LANG_RC[256]={-1,-1,......,0};
</code></p>

<p>改好之后切换到对应目录下，重新make</p>

<p><code>sh
cd ~/hustoj-read-only/core/
./make.sh
</code></p>

<p>接下来就是体力活了，找到提交的runid，rejudge下，看看是不是AC了，可能还会接着RE，如果RE，就将新的callid(是一个数字)加入到数组中，也就是RV数组中，RC数组值为-1就行：</p>

<p><code>sh
sudo judge_client 2028 0 /home/judge/ debug Y
</code></p>

<p>直到返回值不是10，然后再去页面提交，这下应该就可以了~~~（当然我中间还做了一堆傻事，这儿就不提了）
偶尔可以在训练oj上做做练习了，免得以后笔试说不定都跪。</p>

<p>最终结果：
<img src="http://unkeltao.qiniudn.com/img/IMG_ruby_2.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
