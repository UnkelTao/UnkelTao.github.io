<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ACM | /UnkelTao]]></title>
  <link href="http://www.UnkelTao.com/blog/categories/acm/atom.xml" rel="self"/>
  <link href="http://www.UnkelTao.com/"/>
  <updated>2014-03-16T13:16:40+08:00</updated>
  <id>http://www.UnkelTao.com/</id>
  <author>
    <name><![CDATA[UnkelTao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[codeforce 235]]></title>
    <link href="http://www.UnkelTao.com/blog/2014/03/11/codeforce-235/"/>
    <updated>2014-03-11T14:02:19+08:00</updated>
    <id>http://www.UnkelTao.com/blog/2014/03/11/codeforce-235</id>
    <content type="html"><![CDATA[<p>好久没做CF了，觉得再不做估计以后笔试都过不鸟，于是还得经常做一做。</p>

<p>CF的回滚对我木有影响阿，我已经好久没做了似乎。</p>

<p>这次的DIV2似乎比以前的简单一点。</p>

<h2><a href="http://codeforces.com/contest/401/problem/A">A. Vanya and Cards</a></h2>

<p>送分,大概给你一堆数，问你最少还需要几个绝对值不超过X的数能够让他们的和为0.</p>

<p><code>ruby
n,x = gets.chomp!.split.map { |e|  e.to_i}
sum = gets.split.collect{|x| x.to_i}.inject{|y, x| y += x}
p (sum.abs + x -1)/x
</code></p>

<!--more-->


<h2><a href="http://codeforces.com/contest/401/problem/B">B. Sereja and Contests</a></h2>

<p>模拟题
```ruby
n,k = gets.chomp!.split.map { |e|  e.to_i}
A = Array.new(n) { |i|  0}
k.times {<br/>
   c,d1,d2 =  gets.chomp!.split.map { |e|  e.to_i}
   A[d1-1] = 1
   if d2 != nil</p>

<pre><code> A[d2-1] = 1
</code></pre>

<p>   end
}</p>

<p>mx=0
mi=0
cur=0
(n-1).times do |i|
   if A[i] == 0</p>

<pre><code>    cur += 1
</code></pre>

<p>   else</p>

<pre><code>   mx += cur
   mi += (cur+1)/2
   cur = 0  
</code></pre>

<p>   end<br/>
end</p>

<p>mx += cur
mi += (cur+1)/2
puts &ldquo;#{mi} #{mx}&rdquo;
```</p>

<h2><a href="http://codeforces.com/contest/401/problem/C">C. Team</a></h2>

<p>也是模拟题，给你n个1，m个0，让你给出一种排列，不能有3个1连在一起，不能有两个0连在一起，给出任意一种方案即可，不能则输出-1
```ruby
m,n = gets.chomp!.split.map { |e|  e.to_i}
if n+1 &lt; m</p>

<pre><code>p -1
exit
</code></pre>

<p>elsif (m+1)*2 &lt; n</p>

<pre><code>p -1
exit
</code></pre>

<p>end</p>

<p>if n == m</p>

<pre><code>n.times{printf "10" }
puts ""
</code></pre>

<p>elsif m == n+1</p>

<pre><code>n.times{print "01"}
puts 0
</code></pre>

<p>elsif (m+1)*2 == n</p>

<pre><code>m.times{printf "110"}
puts "11"
</code></pre>

<p>elsif m*2 == n</p>

<pre><code>m.times{print "110"}
puts ""
</code></pre>

<p>else</p>

<pre><code>k = n - 1 - m
(k).times {print "110"}
(m-k).times{print "10"}
puts "1"
</code></pre>

<p>end
```</p>

<h2><a href="http://codeforces.com/contest/401/problem/D">D. Roman and Numbers</a></h2>

<p>暴力+状态压缩。
题意：给你一个不超过18位的数n,和不超过100的m,将n进行重排(改变里面的位置，当然0不能排在最前面)，问有多少个数是m的倍数。
ruby似乎跑的很慢，不幸TLE的，C++可以过</p>

<p>```ruby
n,m = gets.chomp!.split
m = m.to_i
len = n.size
dp = Array.new((1&lt;&lt;len)+2) {Array.new(m+5,0)}
dp[0][0] = 1</p>

<p>(1&lt;&lt;len).times do |i|</p>

<pre><code>m.times { |j|  
    tp = Array.new(20,0)
    len.times{|k|
        t = n[k].chr.to_i
        if i&amp;(1&lt;&lt;k) != 0 || (i==0 &amp;&amp; t==0) || tp[t] !=0 
            next
        end
        tp[t] = 1
        dp[i|(1&lt;&lt;k)][(j*10+t)%m] +=dp[i][j]
    }   
}
</code></pre>

<p>end
p dp[(1&lt;&lt;len)-1][0]
```</p>

<h2><a href="http://codeforces.com/contest/401/problem/E">E. Olympic Games</a></h2>

<p>略难，暂时不会</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Hustoj添加ruby支持]]></title>
    <link href="http://www.UnkelTao.com/blog/2014/03/02/ruby-for-hustoj/"/>
    <updated>2014-03-02T22:33:16+08:00</updated>
    <id>http://www.UnkelTao.com/blog/2014/03/02/ruby-for-hustoj</id>
    <content type="html"><![CDATA[<p>虽然已经不是再搞ACM了，但是算法偶尔还是要练习一下写代码，然后最近学习ruby中，打算用ruby来写写ACM题目也算熟悉ruby，免得不用就忘记了，记得Hustoj是可以支持Ruby的，于是就在我们学校的训练Oj上提交了A+B的Ruby代码：
```ruby
readlines.each{|line|</p>

<pre><code>p line.split.collect{|x| x.to_i}.inject{|y, x| y += x}
</code></pre>

<p>}
```
于是华丽的给了我一个WA~~~正在想怎么可能，想起来服务器上没有装ruby，于是远程到7509的服务器上再ssh到训练oj的服务器(只能内网访问，ping不到外网地址)，将ruby装上。</p>

<p>然后就开始了无止境的RE生涯，简直无情，各种call禁止：</p>

<!--more-->


<p><img src="http://unkeltao.qiniudn.com/img/IMG_ruby_1.png" alt="" /></p>

<p>在hustoj的wiki页面上，终于找到了参考的添加其他<a href="http://code.google.com/p/hustoj/wiki/AddProgrammingLanguage">语言支持的方法</a></p>

<p>其实主要的就是找到所有的call编号，放到数组里面去就行了，ruby对应了两个数组</p>

<p>```rb</p>

<h1>保存为Main.rb</h1>

<p>readlines.each{|line|</p>

<pre><code>p line.split.collect{|x| x.to_i}.inject{|y, x| y += x}
</code></pre>

<p>```</p>

<p>terminal中运行如下命令。</p>

<p><code>sh
strace -ff ruby Main.rb 2&gt;&amp;1|awk -F\( '{print $1}'|sort -u
</code></p>

<p>然后会产生,以access开头，write结束（也有可能是其他）的一些列标志如下：</p>

<p><code>
access
xxx
xxx
write
</code></p>

<p>把这些标志放入如下过程，结尾是0，对应RC数组其他值为-1，结尾为0.
<code>c++
int LANG_RV[256]={SYS_access,SYS_write.....,0};
int LANG_RC[256]={-1,-1,......,0};
</code></p>

<p>改好之后切换到对应目录下，重新make</p>

<p><code>sh
cd ~/hustoj-read-only/core/
./make.sh
</code></p>

<p>接下来就是体力活了，找到提交的runid，rejudge下，看看是不是AC了，可能还会接着RE，如果RE，就将新的callid(是一个数字)加入到数组中，也就是RV数组中，RC数组值为-1就行：</p>

<p><code>sh
sudo judge_client 2028 0 /home/judge/ debug Y
</code></p>

<p>直到返回值不是10，然后再去页面提交，这下应该就可以了~~~（当然我中间还做了一堆傻事，这儿就不提了）
偶尔可以在训练oj上做做练习了，免得以后笔试说不定都跪。</p>

<p>最终结果：
<img src="http://unkeltao.qiniudn.com/img/IMG_ruby_2.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MemSQL start]]></title>
    <link href="http://www.UnkelTao.com/blog/2013/08/04/memsql-start/"/>
    <updated>2013-08-04T20:13:34+08:00</updated>
    <id>http://www.UnkelTao.com/blog/2013/08/04/memsql-start</id>
    <content type="html"><![CDATA[<p>【测试代码】</p>

<p>昨晚的CF略晚~~而且提示说div2的少年们，你们很可能会爆0~~~</p>

<p>于是赤裸裸的去了，然后悲催的爆0了</p>

<p>只看了A、B两题~~A题觉得挺简单的，敲了个2分交上去过了Pass，想了想B觉得没有想法就睡觉了。。。</p>

<!--more-->


<p>早上一起洗个澡吃完早餐一看<del>WA了</del>然后看了下代码，我去，尼玛有一行特判输出没改，直接注释掉没用的特判就过了</p>

<p>说说A题吧，题意大概是一串字符串，求一个长度为k的子串，是的用最少的该子串来构成源串，你可以使用子串的其中任意个字符按照你想要的方式排序拼接,输出需要的最少个数和该k子串。</p>

<p>解法：数据那么弱，统计下源串每个字母的个数，直接暴力匹配从1个到(n+k-1)/k个能否拼成源串就好,写的2分,也过了.</p>

<p>```c++</p>

<h1>include <cstdio></h1>

<h1>include <cstdlib></h1>

<h1>include <cstring></h1>

<h1>include <cmath></h1>

<h1>include <climits></h1>

<h1>include <cctype></h1>

<h1>include <ctime></h1>

<h1>include <algorithm></h1>

<h1>include <iostream></h1>

<h1>include <queue></h1>

<h1>include <vector></h1>

<h1>include <set></h1>

<h1>include <map></h1>

<h1>include <stack></h1>

<h1>define SQR(x) ((x)*(x))</h1>

<h1>define rep(i, n) for (int i=0; i&lt;(n); ++i)</h1>

<h1>define repd(i,n)  for(int i=1;i&lt;=(n);++i)</h1>

<h1>define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)</h1>

<h1>define reps(i, a, b) for (int i=(a); i>=(b); &mdash;i)</h1>

<h1>define PB push_back</h1>

<h1>define MP(A, B) make_pair(A, B)</h1>

<h1>define pow2(n) (1&lt;&lt;(n))</h1>

<h1>define pi acos(-1)</h1>

<h1>define eps 0.00000001</h1>

<h1>define lg(n) log10((n)*1.0)</h1>

<h1>define MaxN  1000000</h1>

<h1>define mod 10e+7</h1>

<h1>define ll long long</h1>

<h1>define typed int</h1>

<p>using namespace std;
void data(){
   freopen(&ldquo;data.in&rdquo;,&ldquo;r&rdquo;,stdin);
   freopen(&ldquo;data.out&rdquo;,&ldquo;w&rdquo;,stdout);
}
char s[1100];
int su[27];
int k;
int jd(int n){
   int cnt=0;
   rep(i,26){
       cnt+=(su[i]+n-1)/n;
   }
   if(cnt&lt;=k) return 1;
   else return 0;
}
void pt(int n){
 //  cout&lt;&lt;&ldquo;pt&rdquo;&lt;&lt;endl;  
   cout&lt;&lt;n&lt;&lt;endl;   
   string ss=&ldquo;&rdquo;;
   int cnt=0;
   rep(i,26){
      rep(j,(su[i]+n-1)/n){ ss+=(i+&lsquo;a&rsquo;);cnt++;}
   }
   cout&lt;&lt;ss;
   rep(i,k-cnt)cout&lt;&lt;&lsquo;a&rsquo;;
   cout&lt;&lt;endl;
}
void bit(int l,int r){
     while(l&lt;r){
     int mid=(l+r)/2;
     int kk=jd(mid);
       if(kk>0) r=mid;
       else l=mid+1;   
     }
     pt(l);
}
 
int main(){
   while(cin>>s>>k){
     rep(i,26) su[i]=0;
     rep(i,strlen(s))su[s[i]&ndash;&lsquo;a&rsquo;]++;
     int ma=0,cnt=0;
     rep(i,26)if(su[i]){cnt++;ma=max(ma,su[i]);}
     if(k&lt;cnt)cout&lt;&lt;-1&lt;&lt;endl;
     else{
       
         
        //bit((strlen(s)+k-1)/k,ma+1); //2分
        repd(i,strlen(s)){   //暴力
           if(jd(i)){pt(i);break;}
        }
     }
   }       
   return 0;
}
```</p>

<p>B题一看最长回文子序列，能想到的方法就是2维DP出LCS<del>可是源串长度为50000，2维DP肯定挂</del>早上起来，顺带看了一眼，发现一个条件，回文最长为100（大于100输出100的就行）,这个想了下，就好搞了.一共26字母，说明在2600个字母序列里面肯定会产生回文长度至少是100的。。</p>

<p>这样超过长度2600的就可以直接DP前2600个字母就行了<del>然后就是模板题了</del>真是弱爆了~~</p>

<p>```c++</p>

<h1>include <cstdio></h1>

<h1>include <cstdlib></h1>

<h1>include <cstring></h1>

<h1>include <cmath></h1>

<h1>include <climits></h1>

<h1>include <cctype></h1>

<h1>include <ctime></h1>

<p> </p>

<h1>include <algorithm></h1>

<h1>include <iostream></h1>

<h1>include <queue></h1>

<h1>include <vector></h1>

<h1>include <set></h1>

<h1>include <map></h1>

<h1>include <stack></h1>

<p> </p>

<h1>define SQR(x) ((x)*(x))</h1>

<h1>define rep(i, n) for (int i=0; i&lt;(n); ++i)</h1>

<h1>define repd(i,n)  for(int i=1;i&lt;=(n);++i)</h1>

<h1>define repf(i, a, b) for (int i=(a); i&lt;=(b); ++i)</h1>

<h1>define reps(i, a, b) for (int i=(a); i>=(b); &mdash;i)</h1>

<h1>define PB push_back</h1>

<h1>define MP(A, B) make_pair(A, B)</h1>

<h1>define pow2(n) (1&lt;&lt;(n))</h1>

<h1>define pi acos(-1)</h1>

<h1>define eps 0.00000001</h1>

<h1>define lg(n) log10((n)*1.0)</h1>

<h1>define MaxN  50000</h1>

<h1>define mod 10e+7</h1>

<h1>define ll long long</h1>

<h1>define typed int</h1>

<p>using namespace std;
void data(){
   freopen(&ldquo;data.in&rdquo;,&ldquo;r&rdquo;,stdin);
   freopen(&ldquo;data.out&rdquo;,&ldquo;w&rdquo;,stdout);
}
int dp[2620][2620];
char c[MaxN+100],a[2620],b[2620];
int k[2620][2620];
int cnt[27];
void LCS(int len){
     int i, j;
      rep(i,len+1){ dp[i][0]=dp[0][i]=0;}
      repd(i,len)
        repd(j,len)
        {
            if(a[i]==b[j]){
                k[i][j]=0;
                dp[i][j]=1+dp[i-1][j-1]; 
            }
            else if(dp[i-1][j]>=dp[i][j-1]){
                k[i][j]=1;
                dp[i][j]=dp[i-1][j];
            }
            else{
                 k[i][j]=-1;
                 dp[i][j]=dp[i][j-1];
            }        
        }
}
char st[2610];
int num;
void pt(int m,int n){
   if(n==0||m==0) return ;
   if(k[m][n]==0){
     pt(m-1,n-1);
     st[num++]=a[m];
   }
   else if(k[m][n]>0) pt(m-1,n);
   else pt(m,n-1); 
}
int main(){
    //data();
    while(~scanf(&ldquo;%s&rdquo;,c+1)){                           
     int len=strlen(c+1);
     num=0;
     bool fg=1;
     repd(i,len){
         cnt1-&lsquo;a&rsquo;]++;
         if(cnt1-&lsquo;a&rsquo;]>=100){
           rep(j,100)cout&lt;&lt;c[i];
           cout&lt;&lt;endl;fg=0;break;
         }
     }
     if(!fg)continue;
     if(len>2602) len=2602;
     repd(i,len){a[i]=c[i];b[len+1-i]=c[i];}
     LCS(len);
     pt(len,len);
     if(num&lt;=100)printf(&ldquo;%s\n&rdquo;,st);
     else{
       rep(i,50)cout&lt;&lt;st[i];reps(i,49,0)cout&lt;&lt;st[i]; cout&lt;&lt;endl; 
     }
     
    }          
   return 0;
}
```</p>

<p>（效果似乎一般）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The 9th SWJTU Collegiate Programming Contest Qualification Round]]></title>
    <link href="http://www.UnkelTao.com/blog/2013/04/14/the-9th-swjtu-collegiate-programming-contest-qualification-round/"/>
    <updated>2013-04-14T06:16:28+08:00</updated>
    <id>http://www.UnkelTao.com/blog/2013/04/14/the-9th-swjtu-collegiate-programming-contest-qualification-round</id>
    <content type="html"><![CDATA[<p><strong>比赛链接：</strong>  <a href="http://acm.swjtu.edu.cn/JudgeOnline/showcontest?contest_id=1135" title="第九届ACM校赛资格赛">第九届ACM校赛资格赛</a></p>

<p>资格赛嘛，本着大家熟悉环境增强自信心的原则~10道题没有太难的题目~适合新手练习.本次比赛D、E、F是我出的，本着简单的想法却没想到坑了一部分人，其中E题的数据再随机的时候超出了题目描述的范围造成一些人AC的程序WA了，在此表示抱歉,致以诚挚的歉意。下面给出我对着10道题的解法，可能我的解法并不是完全正确恰好过了数据而已，欢迎大家指正。</p>

<!--more-->


<h2>A <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1982">A+B</a></h2>

<p>完全熟悉OJ环境的题目,上面都有标程,第一次接触ACM的需要知道怎么多组输入.
```c++
int a, b;
while(scanf(&ldquo;%d %d&rdquo;, &amp;a, &amp;b)==2){</p>

<pre><code>printf("%d\n", a + b);
</code></pre>

<p>}
```</p>

<h2>B <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1986">猴子爬楼梯1</a></h2>

<p>因为数据不大，可以有3中解法:</p>

<ul>
<li><p>原理：看 n能被被整除<code>GCD(a,b)</code>整除，推论过程略,详见大牛(<a href="http://blog.csdn.net/openspirit/article/details/8797246">大牛题解</a>)。</p></li>
<li><p>模拟法：我们可以确定只要大于 <code>a+b-1</code>的数 我们都可以通过加上a来得到,在+a ,-b的过程中，通过模拟产生出<code>(1，a+b-1)</code>所有的可能,把n对a取模既可以。</p></li>
<li><p>搜索或者暴力,记忆化搜索，也就1000个点而已,代码未写,参见C题。<br/>
<code>c++
//模拟法
int s[10000];
int cnt(int a,int b)
{
int tmp=a,cur=0;
memset(s,0,sizeof(s));
while(tmp!=0)
{
    s[cur++]=tmp;         
    if(tmp&gt;=b)tmp-=b;
    else tmp+=a;           
}
return cur;
}
</code></p></li>
</ul>


<h2>C <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1990">猴子爬楼梯2</a></h2>

<p><strong>本题将我深深的伤害了</strong></p>

<ul>
<li><p>模拟法:看着数据不大，于是暴力模拟,无限WA,基本思路同B题二解法，只是模拟过程中出现大于top就停止,至今未AC，未发现错误数据，回头对拍,有待考证。(<strong>忘记加特判了<code>a=0,b=0</code>时候挂掉了, 加上AC</strong>)</p></li>
<li><p>记忆化搜索</p></li>
</ul>


<p>```c++
//模拟法</p>

<h1>include<cstdio></h1>

<h1>define rep(i,a,n) for (int i=(a); i&lt;(n); ++i)</h1>

<p>int gcd(int a,int b){return b?gcd(b,a%b):a;}
int s[1000];
int cnt(int a,int b)
{</p>

<pre><code>int tmp=a,cur=0;
if(b==0){s[0]=a; return 1;}
while(tmp!=0){s[cur++]=tmp;if(tmp&gt;=b)tmp-=b;else tmp+=a;} 
return cur;
</code></pre>

<p>}
int main()
{</p>

<pre><code>//freopen("data.in","r",stdin);
//freopen("data2.out","w",stdout);
int T,a,b,n,m;
scanf("%d",&amp;T);
while(T--){
   scanf("%d%d%d%d",&amp;a,&amp;b,&amp;n,&amp;m);
   if(n&gt;m||a==0) printf("NO\n");
   else {
      if(n%a==0) printf("YES\n");
      else {  
           int len=cnt(a,b);
           n=n%a; 
           bool fg=0;
           rep(i,0,len){
              if(s[i]==n) {fg=1;break;}
              if(s[i]&gt;m){fg=0;break;}
           }
           if(fg)printf("YES\n");else printf("NO\n");  

      }
   }
}
return 0;
</code></pre>

<p>}
<code>
</code>c++
//记忆化搜索
bool used[1100];
bool bfs(int a,int b,int n,int m)
{</p>

<pre><code>queue&lt;int&gt; q;
memset(used,0,sizeof(used));
if(a&gt;m) return 0;
q.push(a);
used[a]=1;
int t;
while(!q.empty())
{
   int tmp=q.front(); q.pop();
   used[tmp]=1;
   if(tmp==n) return 1;
   if(tmp+a&lt;=m&amp;&amp;!used[tmp+a]){used[tmp+a]=1; q.push(tmp+a);}
   if(tmp-b&gt;=0&amp;&amp;!used[tmp-b]){used[tmp-b]=1; q.push(tmp-b);}           
}
return 0;
</code></pre>

<p>}
```</p>

<h2>D <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1991">统计学号</a></h2>

<p>排序下，扫描一遍即可，秒杀级水题一枚。不会快排的可冒泡。</p>

<p>```c++</p>

<h1>include<cstdio></h1>

<h1>include<cstring></h1>

<h1>include<iostream></h1>

<h1>include<algorithm></h1>

<p>using namespace std;</p>

<h1>define rep(i,a,n) for (int i=(a); i&lt;(n); ++i)</h1>

<p>int a[110];
int main()
{
 //   freopen(&ldquo;data.in&rdquo;,&ldquo;r&rdquo;,stdin);
 //   freopen(&ldquo;data.out&rdquo;,&ldquo;w&rdquo;,stdout);</p>

<pre><code>int T,n;
scanf("%d",&amp;T);
while(T--){
   scanf("%d",&amp;n);
   rep(i,0,n)scanf("%d",&amp;a[i]);
   sort(a,a+n);
   int cnt=1;
   rep(i,1,n) {if(a[i]!=a[i-1])cnt++;}
   printf("%d\n",cnt);        
}
return 0;
</code></pre>

<p>}
```</p>

<h2>E <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1992">德德的嗜好2.0</a></h2>

<p>此题也是一个排序题，当然如果直接<code>strcmp</code>是不行的，考虑90 9这组数据，结果很明显应该是990而不是909。<br/>
因为我们在排序的时候只要保证<code>(a+b)>(b+a)</code>即可。<br/>
<strong>再次表示对数据中出现了大于1000的数表示抱歉</strong>
```c++</p>

<h1>include<cstdio></h1>

<h1>include<cstring></h1>

<h1>include<iostream></h1>

<h1>include<algorithm></h1>

<p>using namespace std;</p>

<h1>define rep(i, n) for (int i=0; i&lt;(n); ++i)</h1>

<p>string s[81];
bool cmp(string a,string b)
{</p>

<pre><code> return (a+b)&gt;(b+a);
</code></pre>

<p>}
int main()
{</p>

<pre><code>//freopen("data.in","r",stdin);
//freopen("data.out","w",stdout);
int T,n;
cin&gt;&gt;T;
while(T--)
{
  cin&gt;&gt;n;
  rep(i,n)cin&gt;&gt;s[i];
  sort(s,s+n,cmp);   
  rep(i,n)cout&lt;&lt;s[i];
  cout&lt;&lt;endl;    
}
return 0;
</code></pre>

<p>}
```</p>

<h2>F <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1993">德德的嗜好3.0</a></h2>

<p>公式题或者找规律  <code>b(8k+m)=b(m)+60k;  (k=n/8;m=n%8)</code> 打表出前8项就够了;其中<code>b(0)=-1;</code> 可以m等于1到8~这样就用不到b(0)但是计算k,m就多了几行代码。<br/>
下面是推论：</p>

<ul>
<li><p>由于<code>a(n+15)-a(n)=60</code>,故若<code>a(n)</code>是3或5的倍数,当且仅当<code>a(n+15)</code>是3或5的倍数.</p></li>
<li><p>于是每15个数是一个周期，前15个3-59~所以划分区间。</p></li>
<li><p>现将数轴正向分成一系列长为60的区间段: <code>(0,+?)＝(0,60]∪(60,120]∪(120,180]∪…,</code>注意第一个区间段中含有{a(n)}的项15个,即<code>3,7,11,15,19,23,27,31,35,39,43,47,51,55,59</code>其中属于{ }的项8个,为:<code>b(1)=7, b(2)=11, b(3)=19, b(4)=23,   b(5)=31, b(6)=43, b(7)=47, b(8)=59</code></p></li>
<li><p>于是每个区间段中恰有15个{ }的项,8个{ }的项,且有<code>b(8k+m)-b(m)=60k;</code></p></li>
<li><p>EG：由于<code>2006＝8×250+6</code>,而<code>b(6)=43</code>,所以<code>b(2006)=60*250+b(6)=15043</code>。</p></li>
</ul>


<p>```c++</p>

<h1>include<cstdio></h1>

<h1>include<cstring></h1>

<h1>include<iostream></h1>

<h1>include<algorithm></h1>

<p>using namespace std;</p>

<h1>define ll long long</h1>

<h1>define rep(i, n) for (int i=0; i&lt;(n); ++i)</h1>

<p>int b[8]={-1,7,11,19,23,31,43,47};</p>

<p>int main()
{</p>

<pre><code>//freopen("data.in","r",stdin);
//freopen("data.out","w",stdout);
int T,n;
scanf("%d",&amp;T);
while(T--)
{
    scanf("%d",&amp;n);  
    ll ans=60LL*(n/8)+b[n%8];
    printf("%lld\n",ans);    
}
return 0;
</code></pre>

<p>}
```</p>

<h2>G <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1994">不知道自己不知道</a></h2>

<p>没什么好说的
<code>c
while(~scanf("%d",&amp;n)) printf("%d\n",2013-n);
</code></p>

<h2>H <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1995">知道自己不知道</a></h2>

<p>数组求和除以M向上取整.<br/>
<code>
rep(i,0,n)  scanf("%d",&amp;a);
sum+=a;     
printf("%d\n",(sum+m-1)/m); //加上m-1为向上取整
</code></p>

<h2>I <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1996">不知道自己知道</a></h2>

<p>暴力比较即可
```c++</p>

<h1>define rep(i,a,n) for (int i=(a); i&lt;(n); ++i)</h1>

<p>string s[110];
int main()
{</p>

<pre><code>int t=0,T,m,n;
cin&gt;&gt;T;
string qurry;
while(t++&lt;T)
{
    cin&gt;&gt;m;
    rep(i,0,m){cin&gt;&gt;s[i];}
    cin&gt;&gt;n;
    cout&lt;&lt;"Case #"&lt;&lt;t&lt;&lt;":"&lt;&lt;endl;
    rep(i,0,n){
      cin&gt;&gt;qurry;
      bool fg=0;
      rep(j,0,m){if(qurry==s[j]){fg=1;break;}}
      if(fg)cout&lt;&lt;"Yes"&lt;&lt;endl;
      else cout&lt;&lt;"No"&lt;&lt;endl;
    }        
}
return 0;
</code></pre>

<p>}
```</p>

<h1>J <a href="http://acm.swjtu.edu.cn/JudgeOnline/showproblem?problem_id=1997">知道自己知道</a></h1>

<p>做一下结构体，保存i和和i出现的次数，有负数，i集体加上100，然后恢复即可。
```c++</p>

<h1>define rep(i,a,n) for (int i=(a); i&lt;(n); ++i)</h1>

<p>struct pt{</p>

<pre><code>int cnt;
int i;  
</code></pre>

<p>};
pt s[550];
bool cmp(pt a,pt b){</p>

<pre><code> if(a.cnt==b.cnt) return a.i&lt;b.i;     
 return a.cnt&gt;b.cnt;
</code></pre>

<p>}
int main(){</p>

<pre><code>int t,n,a;
scanf("%d",&amp;t);
while(t--){
    rep(i,0,500){s[i].i=i-100;s[i].cnt=0;}
    scanf("%d",&amp;n);
    rep(i,0,n)  {  scanf("%d",&amp;a);      s[a+100].cnt++; }
    sort(s,s+500,cmp);
    int cnt=0;
    rep(i,0,500){if(s[i].cnt!=0)cnt++;else break;}
    printf("%d",cnt);
    rep(i,0,500){  if(!s[i].cnt)break;  printf(" %d",s[i].i);   }
    printf("\n");
}
return 0;
</code></pre>

<p>}
```</p>

<p>以上题目均为过测试数据的程序，不保证程序完全正确无误，欢迎指正,预赛题目难度很明显会增大很多，大家加油。 3Q</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回文判断 Hash+线段树]]></title>
    <link href="http://www.UnkelTao.com/blog/2012/12/18/huiwen-hash/"/>
    <updated>2012-12-18T17:14:12+08:00</updated>
    <id>http://www.UnkelTao.com/blog/2012/12/18/huiwen-hash</id>
    <content type="html"><![CDATA[<p>比赛的一道题,一直没时间写.最近空了，继续写写水题。</p>

<p>题目描述：</p>

<!--more-->


<h2>Description</h2>

<p>Now we have a long long string, and we will have two kinds of operation on it.<br/>
C i y: change the ith letter to y;<br/>
Q i j: check whether the substring from ith letter to jth letter is a palindrome.</p>

<h2>Input</h2>

<p>There are multiple test cases.<br/>
The first line contains a string whose length is not large than 1,000,000.<br/>
The next line contains a integer N indicating the number of operations.<br/>
The next N lines each lines contains a operation.<br/>
All letters in the input are lower-case.</p>

<h2>Output</h2>

<p>For each query operation, output &ldquo;yes&rdquo; if the corresponding substring is a palindrome, otherwise output &ldquo;no&rdquo;.</p>

<h2>Sample Input</h2>

<p>aaaaa <br/>
4<br/>
Q 1 5 <br/>
C 2 b <br/>
Q 1 5 <br/>
Q 1 3</p>

<h2>Sample Output</h2>

<p>yes <br/>
no <br/>
yes</p>

<p><strong>题意：</strong>给你一串字符串~然后有两种操作：Q a b 询问a到b之间的子串是否是回文 ；C i y 将第i个字母变成y</p>

<p>水题，比赛的时候没有写完,
在学妹的提示下，知道了判断回文可以用hash，正反hash相等的子串就是回文;于是再套上线段树来维护区间的hash值.</p>

<p>```c++</p>

<h1>include<iostream></h1>

<h1>include <cstdio></h1>

<h1>include <cstdlib></h1>

<h1>include <cstring></h1>

<h1>include<algorithm></h1>

<h1>include<cmath></h1>

<h1>define N 1100010</h1>

<h1>define mod 1000000007</h1>

<h1>define ll long long</h1>

<p>using namespace std;</p>

<p>struct Tree
{
   int l;
   int r;
   ll left;
   ll right;  <br/>
};</p>

<p>Tree T[N*2];
char str[N];
int kk[N];</p>

<p>void hashinit(){kk[0]=1; for(int i=1;i&lt;N;i++) kk[i]=kk[i-1]*2%mod;}
Tree cnt(Tree tmp1,Tree tmp2)
{   Tree ans;</p>

<pre><code> ans.l=tmp1.l;
 ans.r=tmp2.r;    
 ans.left=(kk[tmp2.r-tmp2.l+1]*tmp1.left+tmp2.left)%mod;
 ans.right=(kk[tmp1.r-tmp1.l+1]*tmp2.right+tmp1.right)%mod;  
 return ans; 
</code></pre>

<p>}
void init(int i,int l,int r)
{</p>

<pre><code> T[i].l=l;
 T[i].r=r; 
 if(l==r){
    T[i].right=T[i].left=str[l-1]-'a';
    return ;
 }
 init(i&lt;&lt;1,l,(l+r)&gt;&gt;1);
 init(i&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);  
 T[i]=cnt(T[i&lt;&lt;1],T[i&lt;&lt;1|1]);
</code></pre>

<p>}
void update(int i,int k,int w)
{</p>

<pre><code> int ans;
 if(T[i].l==T[i].r){                                      
   if(T[i].l==k)T[i].left=T[i].right=w;          
   return ;                                     
 }

 if(T[i&lt;&lt;1].l&lt;=k&amp;&amp;T[i&lt;&lt;1].r&gt;=k) update(i&lt;&lt;1,k,w);                                 
 if(T[i&lt;&lt;1|1].l&lt;=k&amp;&amp;T[i&lt;&lt;1|1].r&gt;=k)update(i&lt;&lt;1|1,k,w);    
 T[i]=cnt(T[i&lt;&lt;1],T[i&lt;&lt;1|1]);
</code></pre>

<p>}
Tree querry(int i,int l,int r)
{</p>

<pre><code> Tree ans;
 if(T[i].l&gt;=l&amp;&amp;T[i].r&lt;=r)return T[i];                                     
 if(T[i&lt;&lt;1].r&gt;=r)return querry(i&lt;&lt;1,l,r);                                 
 if(T[i&lt;&lt;1|1].l&lt;=l)return querry(i&lt;&lt;1|1,l,r);                                               
 return cnt(querry(i&lt;&lt;1,l,T[i&lt;&lt;1].r),querry(i&lt;&lt;1|1,T[i&lt;&lt;1|1].l,r));
</code></pre>

<p>}
int main()
{</p>

<pre><code>int q,k,a,b;
char qt[2],ch[2];
Tree ans; 
hashinit();
while(~scanf("%s",str)){   
    init(1,1,strlen(str));       
    scanf("%d",&amp;q);
   while(q--){ 
       scanf("%s",&amp;qt);
       if(qt[0]=='C'){
        scanf("%d%s",&amp;k,&amp;ch);
        update(1,k,ch[0]);
       }else{
        scanf("%d%d",&amp;a,&amp;b);
        ans=querry(1,a,b);
        printf("%s\n",ans.right==ans.left?"yes":"no");
       }
   }
}
return 0;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
